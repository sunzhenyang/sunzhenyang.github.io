const t=JSON.parse(`{"key":"v-5c32d1c4","path":"/notes/java/10.%E7%BB%A7%E6%89%BF.html","title":"继承","lang":"zh-CN","frontmatter":{"title":"继承","icon":"java","article":true,"breadcrumb":false,"date":"2023-02-22T00:00:00.000Z","category":["Java"],"tag":["Java基础"],"description":"继承 一种类与类之间的关系，使用已存在的类的定义作为基础建立新类，新类（子类、派生类）的定义可以增加新的数据或新的功能，也可以用父类（基类）的功能，但不能选择性的继承父类 子类会继承父类所有 public 类型的实例变量和方法，但不会继承父类所有的 private 类型变量和方法; 初始化顺序 父类静态成员 > 子类静态成员 > 父类对象构造 > 子类...","head":[["meta",{"property":"og:url","content":"https://codemake.fun/notes/java/10.%E7%BB%A7%E6%89%BF.html"}],["meta",{"property":"og:site_name","content":"Yang's Blog"}],["meta",{"property":"og:title","content":"继承"}],["meta",{"property":"og:description","content":"继承 一种类与类之间的关系，使用已存在的类的定义作为基础建立新类，新类（子类、派生类）的定义可以增加新的数据或新的功能，也可以用父类（基类）的功能，但不能选择性的继承父类 子类会继承父类所有 public 类型的实例变量和方法，但不会继承父类所有的 private 类型变量和方法; 初始化顺序 父类静态成员 > 子类静态成员 > 父类对象构造 > 子类..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-28T09:11:56.000Z"}],["meta",{"property":"article:tag","content":"Java基础"}],["meta",{"property":"article:published_time","content":"2023-02-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-28T09:11:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"继承\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-02-22T00:00:00.000Z\\",\\"dateModified\\":\\"2023-02-28T09:11:56.000Z\\",\\"author\\":[]}"]]},"headers":[],"git":{"createdTime":1677575516000,"updatedTime":1677575516000,"contributors":[{"name":"sunzhenyang","email":"874530670@qq.com","commits":1}]},"readingTime":{"minutes":2.91,"words":872},"filePathRelative":"notes/java/10.继承.md","localizedDate":"2023年2月22日","excerpt":"","autoDesc":true}`);export{t as data};
