import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,a as e,f as t}from"./app-4ebde51b.js";const p={},c=t(`<h2 id="类和对象" tabindex="-1"><a class="header-anchor" href="#类和对象" aria-hidden="true">#</a> 类和对象</h2><ul><li>类是模子，确定对象将会拥有的特征（属性）和行为（方法），是对象的类型</li><li>对象是类的实例表现，是特定类型的数据，声明对象在 <strong>栈</strong> 中，实例化对象在 <strong>堆</strong> 中</li><li>一个 Java 文件中可以存在多个类，多个接口，但是只能存在一个 <code>public</code> 修饰的类或接口，且此时文件名需要与 <code>public</code> 修饰的类或者接口同名</li></ul><h2 id="包" tabindex="-1"><a class="header-anchor" href="#包" aria-hidden="true">#</a> 包</h2><h3 id="命名规范" tabindex="-1"><a class="header-anchor" href="#命名规范" aria-hidden="true">#</a> 命名规范</h3><ul><li>由英文小写字母组成</li><li>创建包：域名倒序 + 模块 + 功能</li><li>一个包中不能存在同名类</li><li><code>package + 包名</code>：指明该文件中定义的类所在的包，一个 java 文件中只能有一条 <code>package</code> 语句</li><li>java 文件中书写顺序：<code>package</code> - <code>import</code> - <code>class</code></li><li>导入包：分别以 <code>*</code> 和 指定类名 进行导入，以类名导入优先级最高</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 加载指定包下的所有直接允许访问的类，无法导入其子包中的类</span>
<span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>animal<span class="token punctuation">.</span></span><span class="token operator">*</span>

<span class="token comment">// 加载指定包下的指定类（优先级最高）</span>
<span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>animal<span class="token punctuation">.</span></span><span class="token class-name">Cat</span>
  
<span class="token comment">// 在程序中直接加载类</span>
<span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>animal<span class="token punctuation">.</span></span>CatTest</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>animal<span class="token punctuation">.</span></span>CatTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="常用系统包" tabindex="-1"><a class="header-anchor" href="#常用系统包" aria-hidden="true">#</a> 常用系统包</h3><table><thead><tr><th>包名</th><th>描述</th></tr></thead><tbody><tr><td><code>java.lang</code></td><td>包含 java 语言基础的类，该包在系统加载时<strong>默认导入</strong></td></tr><tr><td><code>java.util</code></td><td>包含 java 语言种常用工具，如：Scanner、Random</td></tr><tr><td><code>java.io</code></td><td>包含输入输出相关功能的类，如：File、InputStream</td></tr></tbody></table><h2 id="构造方法" tabindex="-1"><a class="header-anchor" href="#构造方法" aria-hidden="true">#</a> 构造方法</h2><blockquote><p>用于生成并初始化对象，针对不同的初始化状态，设置不同参数的构造方法</p></blockquote><p>格式：<code>访问修饰符 类名(参数列表){ *** }</code></p><ul><li>方法名与类名相同，包括大小写</li><li>没有返回值，也不能用 <code>void</code> 修饰</li><li>只能在对象实例化（ <code>new</code> ）时调用，不能通过对象名、类名等其它形式调用</li><li>在非构造方法中，智能结合对象实例化操作被调用，不能通过方法名被访问</li><li>当没有指定构造方法时，编译系统会自动添加无参无反的构造方法</li><li><strong>当有指定构造方法，无论是有参、无参的构造方法，编译器都不会自动添加无参的构造方法</strong></li><li>一个类中可以包含多个构造方法，只要满足参数类型、顺序、个数不同即可，也称为 <strong>构造方法重载</strong></li><li>多个构造方法之间可以使用 <strong><code>this()</code></strong> 进行调用 <ul><li>带参时需按顺序传入设定的参数</li><li>调用动作必须在构造函数的第一行</li><li>一个构造方法中只能调用一个构造方法</li><li>不能在类中普通成员方法内通过 <code>this()</code> 调用构造方法</li><li>不能与 <code>super()</code> 共存</li></ul></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Monkey</span><span class="token punctuation">{</span>
    <span class="token comment">// 构造方法</span>
    <span class="token keyword">public</span> <span class="token class-name">Monkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="成员属性默认值" tabindex="-1"><a class="header-anchor" href="#成员属性默认值" aria-hidden="true">#</a> 成员属性默认值</h2><table><thead><tr><th>数据类型</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>字节型</td><td>0</td></tr><tr><td>short</td><td>短整型</td><td>0</td></tr><tr><td>int</td><td>整型</td><td>0</td></tr><tr><td>long</td><td>长整型</td><td>0</td></tr><tr><td>float</td><td>单精度浮点型</td><td>0.0</td></tr><tr><td>double</td><td>双精度浮点型</td><td>0.0</td></tr><tr><td>char</td><td>字符型</td><td>空字符</td></tr><tr><td>String</td><td>字符串型</td><td>null</td></tr><tr><td>boolean</td><td>布尔型</td><td>false</td></tr></tbody></table><h2 id="成员方法" tabindex="-1"><a class="header-anchor" href="#成员方法" aria-hidden="true">#</a> 成员方法</h2><blockquote><p>根据类型所需任意功能，进行方法设置</p></blockquote><p>格式：<code>访问修饰符 返回值类型 方法名(参数列表){ *** }</code></p><ul><li>方法内定义的局部变量只能在方法里使用</li><li>方法内不能定义静态成员</li><li>不能使用 <code>public</code>、<code>protected</code>、<code>private</code> 修饰</li></ul><h2 id="this-关键字" tabindex="-1"><a class="header-anchor" href="#this-关键字" aria-hidden="true">#</a> this 关键字</h2><ul><li>代表当前对象本身，可以理解为：指向当前对象的一个引用</li><li>可用于调用成员属性、成员方法、构造方法，也可以当做参数进行方法传参以及方法传值</li><li>大部分时候，类的方法中访问成员属性时无需使用 <code>this</code>，但如果方法里存在局部变量和成员属性同名，但程序又需要在该方法里访问成员属性时，则必须使用 <code>this</code> 进行调用</li><li>类的成员方法访问同类中其他成员方法时，<code>this</code> 关键字可加可不加，效果相同</li><li>静态方法中不可使用 <code>this</code></li></ul><h2 id="static-关键字" tabindex="-1"><a class="header-anchor" href="#static-关键字" aria-hidden="true">#</a> static 关键字</h2><h3 id="静态成员" tabindex="-1"><a class="header-anchor" href="#静态成员" aria-hidden="true">#</a> 静态成员</h3><blockquote><p>被 <code>static</code> 修饰的成员变量，通常被称为静态成员、静态属性、类成员、全局属性等，方便在没有创建对象的情况下进行某些操作</p></blockquote><ul><li><p>属于整个类，由类进行维护，仅在类初次加载时会被初始化，在类销毁时回收</p></li><li><p>通过该类实例化的所有对象都共享类中的静态资源，任一对象中静态资源的修改都将影响所有对象</p></li><li><p>由于静态成员在类加载期间就已经完成初始化，存储在 Java Heap（JDK7.0 之前存储在方法区）中静态存储区，因此优先于对象而存在，可以通过类名和对象名两种方式访问</p><ul><li><code>类.成员</code>（推荐）</li><li><code>对象.成员</code></li></ul></li><li><p>可以将频繁调用的公共信息、期望加快运行效率的成员设置为静态。但需注意，由于其生命周期长，即资源占用周期长，要慎用。</p></li></ul><h3 id="静态方法" tabindex="-1"><a class="header-anchor" href="#静态方法" aria-hidden="true">#</a> 静态方法</h3><blockquote><p>被 <code>static</code> 修饰的成员方法，通常被称为静态方法、类方法、全局方法等</p></blockquote><ul><li>与静态成员类似，静态方法属于整个类，由类进行维护，优先对象而存在，因此可以通过类名和对象名两种方式访问</li><li>静态方法中不能直接访问同一个类中的非静态成员，只能直接调用一个类中的静态成员</li><li>不允许在方法内部定义静态局部变量</li><li>静态方法中不能使用 <code>this</code></li><li>非静态方法可以通过 <code>类名.成员法</code> 或 <code>成员</code> 或 <code>this.成员</code> 的方式访问类内静态成员/静态方法</li><li>应用 <code>this.静态成员/静态方法</code> 时会出现警告，但不影响程序运行</li></ul><h2 id="代码块" tabindex="-1"><a class="header-anchor" href="#代码块" aria-hidden="true">#</a> 代码块</h2><blockquote><p>执行优先级：<code>静态代码块 &gt; 构造代码块 &gt; 构造方法</code></p></blockquote><h3 id="普通代码块" tabindex="-1"><a class="header-anchor" href="#普通代码块" aria-hidden="true">#</a> 普通代码块</h3><blockquote><p>定义在方法内部，用 <code>{}</code> 括起来的代码段</p></blockquote><ul><li>可以在方法中出现多次，按顺序在方法调用时执行，作用域独立</li><li><strong>适用于在方法内进行代码功能拆分</strong></li></ul><h3 id="构造代码块" tabindex="-1"><a class="header-anchor" href="#构造代码块" aria-hidden="true">#</a> 构造代码块</h3><blockquote><p>定义在类内部，没有被 <code>static</code> 修饰的，用 <code>{}</code> 括起来的代码段</p></blockquote><ul><li>可以在类中出现多次，按顺序在每个对象实例化时执行</li><li><strong>运行顺序（由早到晚）：<code>静态代码块</code> <code>构造代码块</code> <code>构造方法</code></strong></li><li>可以在构造代码块中直接操作静态和非静态成员</li><li><strong>多适用于类中每个对象产生时都需要执行的功能封装。与构造方法的区别在于，构造方法是在 <code>new</code> 执行时有选择性的调用带参或者无参构造，而构造代码块则是在每个对象实例化时都一定会执行</strong></li></ul><h3 id="静态代码块" tabindex="-1"><a class="header-anchor" href="#静态代码块" aria-hidden="true">#</a> 静态代码块</h3><blockquote><p>被 <code>static</code> 修饰的，定义在类内部，用 <code>{}</code> 括起来的代码段</p></blockquote><ul><li>只能出现在类内，不能出现在方法内</li><li>可以出现多次，按顺序在类加载时执行</li><li>无论该类实例化多少对象，只执行一次</li><li>不能在静态代码块中声明静态成员，可以声明非静态成员，静态代码块中声明的成员，在外部无法访问</li><li>不能在静态代码块中直接对非静态成员赋值</li><li><strong>基于性能优化的考量，多适用于需要在项目启动时执行一次的场景，比如项目整体资源加载等</strong></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 普通代码块</span>
<span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 构造代码块</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Book</span><span class="token punctuation">{</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 静态代码块</span>
<span class="token keyword">static</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类" aria-hidden="true">#</a> 抽象类</h2><h3 id="意义" tabindex="-1"><a class="header-anchor" href="#意义" aria-hidden="true">#</a> 意义</h3><ul><li>为子类提供一个公共类型，封装子类中的重复内容（成员变量和方法）</li><li>封装子类当中重复的内容（成员变量和方法）</li><li>可借由父子关系限制子类设计的随意性，在一定程度上避免了无意义父类的实例化</li></ul><h3 id="描述" tabindex="-1"><a class="header-anchor" href="#描述" aria-hidden="true">#</a> 描述</h3><ul><li>抽象类不能实例化，只能通过引用指向子类实例（向上转型）</li><li>含有抽象方法的类一定是抽象类，但是抽象类中可以没有抽象方法</li><li>一个类继承抽象类之后，必须实现其所有的抽象方法，否则也需要设置为抽象类，不同子类对父类的抽象方法可以有不同的实现</li><li>子类只能通过 <code>extends</code> 继承一个抽象父类</li><li>抽象类中的静态成员和方法可以被子类继承应用</li><li>应用场景：某个父类只知道其子类应该包含怎样的方法，但无法知道子类如何实现这些方法</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="抽象方法" tabindex="-1"><a class="header-anchor" href="#抽象方法" aria-hidden="true">#</a> 抽象方法</h3><ul><li><p>抽象方法必须定义在抽象类中</p></li><li><p>抽象方法必须加 <code>abstract</code> 关键字，并且不能有方法体</p></li><li><p>子类必须重写父类抽象方法（如果不想重写父类方法，则需要将子类也设置为抽象类）</p></li><li><p>支持 <code>public</code> 、<code>protected</code> 和默认访问权限</p></li><li><p>不能使用 <code>static</code>、<code>final</code>、<code>private</code> 修饰</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="内部类" tabindex="-1"><a class="header-anchor" href="#内部类" aria-hidden="true">#</a> 内部类</h2><blockquote><p>在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。与之对应，包含内部类的类被称为外部类</p></blockquote><p>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类，更好的实现了信息隐藏</p><h3 id="成员内部类" tabindex="-1"><a class="header-anchor" href="#成员内部类" aria-hidden="true">#</a> 成员内部类</h3><ul><li>内部类中最常见的就是成员内部类，定义在类内部，可以看成是外部类的一个成员，也称为普通内部类</li><li>在成员内部类中 <strong>无法声明静态成员</strong></li><li>内部类在外部使用时，无法直接实例化，需要借由外部类信息才能完成实例化</li><li>内部类的访问修饰符可以任意，但是访问范围会受到影响</li><li>内部类可以直接访问外部类的成员，如果出现同名属性，优先访问内部类中定义的</li><li>可以在内部类中使用 <strong><code>外部类名.this.成员</code></strong> 的方式，访问外部类中的同名信息</li><li>外部类访问内部类信息，需要通过内部类实例，无法直接访问</li><li>内部类编译后 <strong><code>.class</code></strong> 文件命名：<strong><code>外部类名$内部类名.class</code></strong></li><li>应用场景：当两个类（A，B）彼此之间需要相互访问，且对其中某一类的应用限制较高（譬如B只在A的某种特定应用时才需要），可以将B设置为A的成员内部类</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// Person.java</span>
<span class="token comment">// 外部类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
   <span class="token keyword">int</span> age<span class="token punctuation">;</span>

   <span class="token keyword">public</span> <span class="token class-name">Heart</span> <span class="token function">getHeart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Heart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 内部类</span>
   <span class="token keyword">class</span> <span class="token class-name">Heart</span><span class="token punctuation">{</span>
      <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">beat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> <span class="token string">&quot;心脏在跳动&quot;</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// PersonTest.java</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonTest</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">Person</span> zhangsan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 方式1：new 外部类.new 内部类</span>
      <span class="token class-name">Person<span class="token punctuation">.</span>Heart</span> heart1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Heart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 方式2：外部类对象.new 内部类</span>
      <span class="token class-name">Person<span class="token punctuation">.</span>Heart</span> heart2 <span class="token operator">=</span> zhangsan<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Heart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 方式3：外部类对象.获取方法</span>
      <span class="token class-name">Person<span class="token punctuation">.</span>Heart</span> heart3 <span class="token operator">=</span> zhangsan<span class="token punctuation">.</span><span class="token function">getHeart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>heart1<span class="token punctuation">.</span><span class="token function">beat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>heart2<span class="token punctuation">.</span><span class="token function">beat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>heart3<span class="token punctuation">.</span><span class="token function">beat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="静态内部类" tabindex="-1"><a class="header-anchor" href="#静态内部类" aria-hidden="true">#</a> 静态内部类</h3><ul><li>内部类加上 <code>static</code> 修饰符，也称为嵌套内部类，它无需依赖外部类的实例</li><li>静态内部类中，只能直接访问外部类的静态成员，如果需要调用外部非静态成员，可以通过外部对象实例</li><li>可以通过 <code>外部类.内部类.静态成员</code> 的方式，访问内部类中的静态成员</li><li>当内部类属性与外部类属性同名时，默认直接调用内部类中的成员</li><li>如果需要访问外部类中的静态属性，可以通过 <strong><code>外部类.属性</code></strong> 的方式</li><li>如果需要访问外部类中的非静态属性，可以通过 <strong><code>new 外部类().属性</code></strong> 的方式</li><li>使用场景：当类 A 需要使用类 B，而 B 并不需要直接访问外部类 A 的成员变量和方法时，可以将 B 作为 A 的静态内部类</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Heart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>&#39;<span class="token class-name">Hello</span> world<span class="token operator">!</span>&#39;<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取静态内部类对象实例</span>
<span class="token class-name">Person<span class="token punctuation">.</span>Heart</span> heart1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person<span class="token punctuation">.</span>Heart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 测试类中调用静态内部类的静态方法</span>
<span class="token class-name">Person<span class="token punctuation">.</span>Heart</span><span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="方法内部类" tabindex="-1"><a class="header-anchor" href="#方法内部类" aria-hidden="true">#</a> 方法内部类</h3><ul><li>定义在外部类方法中的类，作用范围在方法内，也称局部内部类</li><li>方法内部类中 <strong>不能定义静态成员</strong></li><li>和方法内部成员使用规则一样，不能使用 <code>public</code>、<code>protected</code>、<code>private</code> 修饰</li><li>方法内部类中可以包含 <code>final</code>、<code>abstract</code> 修饰的成员，但不推荐</li><li>类中普通方法如需访问外部方法中的局部变量，则该变量也需定义为final（jdk1.8之后底层默认会给该变量加上final）</li><li>内部类编译后 <code>.class</code> 文件命名：<code>外部类+$数字+内部类.class</code></li><li>应用场景：由于类对象只能在当前方法或者代码块中创建、使用，相当于一次性产品，使用场景比较少</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// Person.java</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getHeart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">class</span> <span class="token class-name">Heart</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">beat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token string">&quot;岁的心脏在跳动&quot;</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      	<span class="token comment">// 这里需要直接返回方法运行结果，因为离开方法之后就访问不到任何方法内部类中的元素</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Heart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// PersonTest.java</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getHeart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="匿名内部类" tabindex="-1"><a class="header-anchor" href="#匿名内部类" aria-hidden="true">#</a> 匿名内部类</h3><ul><li><p>将类的定义与类的创建放到一起完成 <code>new Person(){ ... }</code></p></li><li><p>没有类名，没有 <code>class</code> 关键字，也无法产生具体类实例对象名</p></li><li><p>必须继承或实现一个接口，指定给 new 的类型为匿名类的父类或父接口，但不能有显示的 <code>extends</code> 或 <code>implements</code> 子句</p></li><li><p>编译后的文件命名：<code>外部类$数字.class</code></p></li><li><p>无法在类型名称前添加修饰符 <code>public protected private abstract static</code></p></li><li><p>不能出现构造方法、静态成员、抽象方法，可添加构造代码块</p></li><li><p>匿名内部类可以实现接口也可以继承父类，但是不可兼得</p></li><li><p>适用场景：多可用于作为方法参数或者返回值，然后根据不同类型，无需产生具体类和对象名，返回不同的实现即可。</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// Person.java</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// PersonTest.java</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonTest</span> <span class="token punctuation">{</span>
  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getRead</span><span class="token punctuation">(</span><span class="token class-name">Person</span> person<span class="token punctuation">)</span><span class="token punctuation">{</span>
        person<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">PersonTest</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PersonTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        test<span class="token punctuation">.</span><span class="token function">getRead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;德玛西亚&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        test<span class="token punctuation">.</span><span class="token function">getRead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;万众一心&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="问答" tabindex="-1"><a class="header-anchor" href="#问答" aria-hidden="true">#</a> 问答</h3><blockquote><p>问：方法内部类中为什么不能有静态成员？</p></blockquote><p>答：由于 static 类型的属性和方法，在类加载的时候就会存在于内存中。因此要想使用某个类的static属性和方法，那么这个类必须要先加载到虚拟机中。但是，普通的方法内部类并不会随外部类一起加载，只有在实例化外部类之后才会加载。因此，如果在外部类并没有实例化，内部类还没有加载的时候，直接调用内部类的静态成员或方法，这明显是矛盾的。所以普通的方法内部类不能有静态成员变量或静态方法。</p><br><blockquote><p>问：为什么方法中返回值是 Object，返回的是方法调用还不报错？</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getHeart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">Heart</span><span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">beat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token string">&quot;岁的心脏在跳动&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Heart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>答：这里并不是返回方法调用，而是返回内部类Heart对象的beat方法的返回结果，整个方法最后一句的执行顺序是：1、通过 new 实例化内部类对象。 2、调用其 beat 方法。3、将 beat 方法返回值通过 return 带回，也就是此时的 Object 返回值，此处，也因为 Object 是 Java 中的根类，基于向上转型的原则，可以返回具体的子类String 类型的对象</p><br><blockquote><p>什么是方法签名？</p></blockquote><p>答：在 Java 中，方法签名着重指代：方法名和参数列表（包括：参数的类型、个数以及顺序）</p><br><blockquote><p>接口和抽象类不能直接实例化，为什么下面代码可以这么写？</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// Person.java</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 测试</span>
test<span class="token punctuation">.</span><span class="token function">getRead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;正在读书&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>答：此处并不是实例化 Person，可以理解为是创建了一个没有名字的 Person 类型的子类对象，如下面代码与上面的功能是一致的</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// TempClass.java</span>
<span class="token keyword">class</span> <span class="token class-name">TempClass</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;正在读书&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// PersonTest.java</span>
<span class="token keyword">class</span> <span class="token class-name">PersonTest</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getRead</span><span class="token punctuation">(</span><span class="token class-name">Person</span> person<span class="token punctuation">)</span><span class="token punctuation">{</span>
        person<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">PersonTest</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PersonTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        test<span class="token punctuation">.</span><span class="token function">getRead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TempClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="基本原则-solid" tabindex="-1"><a class="header-anchor" href="#基本原则-solid" aria-hidden="true">#</a> 基本原则（SOLID）</h2><h3 id="单一职责原则-srp" tabindex="-1"><a class="header-anchor" href="#单一职责原则-srp" aria-hidden="true">#</a> 单一职责原则（SRP）</h3><blockquote><p>一个类应该只有一个发生变化的原因</p></blockquote><p>一个类（大到模块、小到方法）承担的职责越多，被复用的可能性就越小，而且当一个类承担的职责过多，就相当于把这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变，则可将它们封装在同一类中。</p><h3 id="开放封闭原则-ocp" tabindex="-1"><a class="header-anchor" href="#开放封闭原则-ocp" aria-hidden="true">#</a> 开放封闭原则（OCP）</h3><h3 id="里氏替换原则-lsp" tabindex="-1"><a class="header-anchor" href="#里氏替换原则-lsp" aria-hidden="true">#</a> 里氏替换原则（LSP）</h3><h3 id="接口分离原则-isp" tabindex="-1"><a class="header-anchor" href="#接口分离原则-isp" aria-hidden="true">#</a> 接口分离原则（ISP）</h3><h3 id="依赖倒置原则-dip" tabindex="-1"><a class="header-anchor" href="#依赖倒置原则-dip" aria-hidden="true">#</a> 依赖倒置原则（DIP）</h3>`,87);function o(l,i){return s(),a("div",null,[e(" more "),c])}const r=n(p,[["render",o],["__file","08.面向对象.html.vue"]]);export{r as default};
