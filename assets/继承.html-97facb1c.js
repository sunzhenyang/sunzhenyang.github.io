import{_ as a,P as l,Q as n,Z as e,a2 as i}from"./framework-f3782457.js";const s={},c=i(`<h4 id="继承" tabindex="-1"><a class="header-anchor" href="#继承" aria-hidden="true">#</a> 继承</h4><blockquote><p>一种类与类之间的关系，使用已存在的类的定义作为基础建立新类，新类（子类、派生类）的定义可以增加新的数据或新的功能，也可以用父类（基类）的功能，但<strong>不能选择性的继承父类</strong></p></blockquote><ul><li>子类会继承父类所有 <code>public</code> 类型的实例变量和方法，但不会继承父类所有的 <code>private</code> 类型变量和方法</li></ul><h5 id="初始化顺序" tabindex="-1"><a class="header-anchor" href="#初始化顺序" aria-hidden="true">#</a> 初始化顺序</h5><blockquote><p>父类静态成员 &gt; 子类静态成员 &gt; 父类对象构造 &gt; 子类对象构造</p><p>访问修饰符不影响成员加载顺序，跟书写位置有关</p></blockquote><h5 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h5><ul><li>利用代码复用</li><li>缩短开发周期</li><li>单继承：子类只能继承一个父类</li><li>父类的私有成员子类不可继承</li><li>父类的构造方法不允许被继承，不允许被重写</li><li>子类构造方法默认调用父类的无参构造</li></ul><h5 id="格式" tabindex="-1"><a class="header-anchor" href="#格式" aria-hidden="true">#</a> 格式</h5><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="super" tabindex="-1"><a class="header-anchor" href="#super" aria-hidden="true">#</a> Super</h5><blockquote><p>父类对象的引用</p></blockquote><ul><li>调用父类可访问的属性</li><li>调用父类方法</li><li>调用父类指定构造方法，要放在子类构造方法的第一行</li><li>子类的构造过程中必须调用其父类的构造方法</li><li>如果子类的构造方法中没有显示标注，则系统默认调用父类的无参构造方法</li><li>不能在静态方法中使用</li><li>不能与 <code>this()</code> 共存</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">super</span><span class="token punctuation">.</span>month<span class="token punctuation">;</span>

<span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> month<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="final-关键字" tabindex="-1"><a class="header-anchor" href="#final-关键字" aria-hidden="true">#</a> final 关键字</h5><ul><li>修饰类：表示该类不允许被继承，<code>public</code> <code>final</code> 关键字顺序可颠倒 <ul><li><code>public final class Animal{}</code></li></ul></li><li>修饰类方法：表示该方法不允许被子类重写，不能用来修饰构造方法 <ul><li><code>public final void eat(){}</code></li></ul></li><li>修饰方法内局部变量：只要在具体使用之前进行赋值即可，一旦赋值不允许被修改 <ul><li><code>final int num; num = 10;</code></li></ul></li><li>修饰内部成员属性：若定义时未被初始化，则只能在构造函数或构造代码块中赋值 <ul><li><code>private final String name;</code></li></ul></li><li>修饰对象，对象的引用不可变，但对象的属性值可变</li><li>可配合 <code>static</code> 使用修饰方法和变量 <ul><li><code>public static final int num = 10;</code></li><li>只需要加载一次后续不需要修订的配置信息</li><li><code>final</code> 修饰的静态变量值必须在声明或静态初始化程序中赋值</li></ul></li><li>可提高性能，但会降低可扩展性</li></ul><h5 id="object-类" tabindex="-1"><a class="header-anchor" href="#object-类" aria-hidden="true">#</a> Object 类</h5><ul><li><p>是多有类的父类</p></li><li><p>一个类没有使用 extends 关键字明确标识继承关系，则默认继承 Object 类（包括数组）</p></li><li><p>每个类都可以使用 Object 类中定义的方法</p></li></ul><h5 id="注解" tabindex="-1"><a class="header-anchor" href="#注解" aria-hidden="true">#</a> 注解</h5><blockquote><p>可以声明包、类、属性、方法、局部变量、方法参数等的前面，用来对这些元素进行说明、注释</p></blockquote><ul><li>按运行机制分类 <ul><li>源码注解：只在源码阶段保留，在编译阶段会被丢弃 <ul><li><code>@Override</code>：标注重写父类方法</li></ul></li><li>编译时注解：在编译时期保留，在加载 class 文件时会被丢弃 <ul><li><code>@NotNull</code>：空值检查</li></ul></li><li>运行时注解：在运行阶段还起作用，甚至会影响运行逻辑的注解 <ul><li><code>@Autowired</code>：依赖注入，自动将外部传入的数据加载进去</li></ul></li></ul></li><li>按来源分类 <ul><li>来自 JDK 的注解</li><li>来自第三方的注解</li><li>自定义的注解</li></ul></li></ul><h6 id="元注解" tabindex="-1"><a class="header-anchor" href="#元注解" aria-hidden="true">#</a> 元注解</h6><blockquote><p>定义注解的注解，对注解进行标注</p></blockquote><ul><li><code>@target</code></li></ul>`,23);function t(o,d){return l(),n("div",null,[e(" more "),c])}const p=a(s,[["render",t],["__file","继承.html.vue"]]);export{p as default};
