const e=JSON.parse(`{"key":"v-b57cc8d6","path":"/technology/javascript/dom/mutationobserver.html","title":"Mutation Observer API","lang":"zh-CN","frontmatter":{"title":"Mutation Observer API","icon":"article","category":"javascript","article":false,"tag":["javascript"],"copyright":"Copyright by 阮一峰","description":"概述 Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。 概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。 这样设计是为了应付 DOM 变动频繁的特点。举例来说，如果文档中连续插入1000个&lt;p&gt;元素，就会连续触发1000个插入事件，执行每个事件的回调函数，这很可能造成浏览器的卡顿；而 Mutation Observer 完全不同，只在1000个段落都插入结束后才会触发，而且只触发一次。","head":[["meta",{"property":"og:url","content":"https://codemake.fun/technology/javascript/dom/mutationobserver.html"}],["meta",{"property":"og:site_name","content":"Yang's Blog"}],["meta",{"property":"og:title","content":"Mutation Observer API"}],["meta",{"property":"og:description","content":"概述 Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。 概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。 这样设计是为了应付 DOM 变动频繁的特点。举例来说，如果文档中连续插入1000个&lt;p&gt;元素，就会连续触发1000个插入事件，执行每个事件的回调函数，这很可能造成浏览器的卡顿；而 Mutation Observer 完全不同，只在1000个段落都插入结束后才会触发，而且只触发一次。"}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-01-11T09:12:15.000Z"}],["meta",{"property":"article:author","content":"Yang"}],["meta",{"property":"article:tag","content":"javascript"}],["meta",{"property":"article:modified_time","content":"2023-01-11T09:12:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"Mutation Observer API\\",\\"description\\":\\"概述 Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。 概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。 这样设计是为了应付 DOM 变动频繁的特点。举例来说，如果文档中连续插入1000个&lt;p&gt;元素，就会连续触发1000个插入事件，执行每个事件的回调函数，这很可能造成浏览器的卡顿；而 Mutation Observer 完全不同，只在1000个段落都插入结束后才会触发，而且只触发一次。\\"}"]]},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"MutationObserver 构造函数","slug":"mutationobserver-构造函数","link":"#mutationobserver-构造函数","children":[]},{"level":2,"title":"MutationObserver 的实例方法","slug":"mutationobserver-的实例方法","link":"#mutationobserver-的实例方法","children":[{"level":3,"title":"observe()","slug":"observe","link":"#observe","children":[]},{"level":3,"title":"disconnect()，takeRecords()","slug":"disconnect-takerecords","link":"#disconnect-takerecords","children":[]}]},{"level":2,"title":"MutationRecord 对象","slug":"mutationrecord-对象","link":"#mutationrecord-对象","children":[]},{"level":2,"title":"应用示例","slug":"应用示例","link":"#应用示例","children":[{"level":3,"title":"子元素的变动","slug":"子元素的变动","link":"#子元素的变动","children":[]},{"level":3,"title":"属性的变动","slug":"属性的变动","link":"#属性的变动","children":[]},{"level":3,"title":"取代 DOMContentLoaded 事件","slug":"取代-domcontentloaded-事件","link":"#取代-domcontentloaded-事件","children":[]}]},{"level":2,"title":"参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"git":{"createdTime":1673428335000,"updatedTime":1673428335000,"contributors":[{"name":"sunzhenyang","email":"874530670@qq.com","commits":1}]},"readingTime":{"minutes":6.35,"words":1905},"filePathRelative":"technology/javascript/dom/mutationobserver.md","localizedDate":"2023年1月11日","excerpt":"<h2> 概述</h2>\\n<p>Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。</p>\\n<p>概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。</p>\\n<p>这样设计是为了应付 DOM 变动频繁的特点。举例来说，如果文档中连续插入1000个<code>&lt;p&gt;</code>元素，就会连续触发1000个插入事件，执行每个事件的回调函数，这很可能造成浏览器的卡顿；而 Mutation Observer 完全不同，只在1000个段落都插入结束后才会触发，而且只触发一次。</p>","autoDesc":true}`);export{e as data};
