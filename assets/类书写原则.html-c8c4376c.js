import{_ as e,P as a,Q as r,Z as d,a2 as h}from"./framework-f3782457.js";const i={},t=h('<h3 id="基本原则-solid" tabindex="-1"><a class="header-anchor" href="#基本原则-solid" aria-hidden="true">#</a> 基本原则（SOLID）</h3><h4 id="单一职责原则-srp" tabindex="-1"><a class="header-anchor" href="#单一职责原则-srp" aria-hidden="true">#</a> 单一职责原则（SRP）</h4><blockquote><p>一个类应该只有一个发生变化的原因</p></blockquote><p>一个类（大到模块、小到方法）承担的职责越多，被复用的可能性就越小，而且当一个类承担的职责过多，就相当于把这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变，则可将它们封装在同一类中。</p><h4 id="开放封闭原则-ocp" tabindex="-1"><a class="header-anchor" href="#开放封闭原则-ocp" aria-hidden="true">#</a> 开放封闭原则（OCP）</h4><h4 id="里氏替换原则-lsp" tabindex="-1"><a class="header-anchor" href="#里氏替换原则-lsp" aria-hidden="true">#</a> 里氏替换原则（LSP）</h4><h4 id="接口分离原则-isp" tabindex="-1"><a class="header-anchor" href="#接口分离原则-isp" aria-hidden="true">#</a> 接口分离原则（ISP）</h4><h4 id="依赖倒置原则-dip" tabindex="-1"><a class="header-anchor" href="#依赖倒置原则-dip" aria-hidden="true">#</a> 依赖倒置原则（DIP）</h4>',8);function s(c,n){return a(),r("div",null,[d(" more "),t])}const l=e(i,[["render",s],["__file","类书写原则.html.vue"]]);export{l as default};
