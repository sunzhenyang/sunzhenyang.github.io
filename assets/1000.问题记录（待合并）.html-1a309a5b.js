import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,a as e,f as o}from"./app-a7d5173b.js";const i={},t=o(`<h2 id="小知识点" tabindex="-1"><a class="header-anchor" href="#小知识点" aria-hidden="true">#</a> 小知识点</h2><ul><li><p>引用独立的 <strong>JavaScript</strong> 文件时，<code>&lt;script&gt;</code> 元素不能包含任何<strong>JavaScript</strong>代码。</p></li><li><p><code>alert()</code>：仅当你要停止一切并提醒用户时，才应使用它</p></li><li><p>在任何情况下，<code>&lt;/script&gt;</code> 结束标签都是必不可少的</p></li><li><p>浏览器分 <strong>两遍</strong> 读取网页:第一遍读取所有的函数定义，第二遍开始执行代码。这让你可以将函数放在文件的任何地方。</p></li><li><p>没有使用 <code>var</code> 声明的变量是全局变量</p></li></ul><h2 id="特殊类型" tabindex="-1"><a class="header-anchor" href="#特殊类型" aria-hidden="true">#</a> 特殊类型</h2><blockquote><p><code>null</code>：在应该提供一个对象，但无法创建或找到时，将提供 null（null 用于表示不存在的对象 typeof null 结果为 object）</p><p><code>undefined</code>：在变量未初始化、对象没有指定属性或数组没有指定元素时，将返回 undefined</p><p><code>NaN</code>：无法表示的数字（typeof NaN 结果为 number），并且 NaN 不等于 NaN，使用函数 <code>isNaN()</code> 检测</p></blockquote><h3 id="相等性判断" tabindex="-1"><a class="header-anchor" href="#相等性判断" aria-hidden="true">#</a> 相等性判断</h3><ul><li><p>类型相同，直接判断</p></li><li><p>类型不同，尝试转换为相同类型再进行比较</p><ul><li>数字和字符串，转换为数字</li><li>布尔值和其他类型，转换为数字再进行比较</li></ul></li><li><p><code>undefined == null</code> 返回 <code>true</code></p></li><li><p>被视为假值的值：<code>undefined</code>、<code>null</code>、<code>0</code> 、<code>空字符串</code>、<code>NaN</code></p></li></ul><h2 id="编码指南" tabindex="-1"><a class="header-anchor" href="#编码指南" aria-hidden="true">#</a> 编码指南</h2><ul><li>在开头声明全局变量</li><li>将函数定义统一放在文件的开头或结尾</li><li>在函数开头声明局部变量</li></ul><h2 id="函数声明与函数表达式" tabindex="-1"><a class="header-anchor" href="#函数声明与函数表达式" aria-hidden="true">#</a> 函数声明与函数表达式</h2><h3 id="浏览器执行流程" tabindex="-1"><a class="header-anchor" href="#浏览器执行流程" aria-hidden="true">#</a> 浏览器执行流程</h3><ul><li><p>浏览器会在执行所有 JS 代码之前分析网页，查找其中的函数声明</p></li><li><p>找到函数声明时</p><ul><li>创建相应的函数</li><li>将得到的函数引用赋值给与函数同名的变量</li></ul></li><li><p>处理所有的函数声明后，浏览器回到代码开头，开始从头到尾顺序执行代码</p><ul><li>如果遇到函数声明，因为之前已经处理够了，所以直接跳过</li></ul></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 函数声明</span>
<span class="token keyword">function</span> <span class="token function">quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;quack&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 函数表达式</span>
<span class="token keyword">var</span> <span class="token function-variable function">fly</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;fly&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h3><ul><li>函数声明是一条语句，可以认为它包含一条隐藏的赋值语句，将函数引用创建并赋值给一个函数同名变量</li><li>函数表达式不自动将函数引用赋值给任何变量，必须显式的这样做，要么将函数（引用）赋值给一个变量，要么以其他方式使用函数表达式</li><li>使用函数声明时，函数将在执行代码前创建</li><li>使用函数表达式时，函数将在运行阶段执行代码时创建</li></ul><h3 id="一等值" tabindex="-1"><a class="header-anchor" href="#一等值" aria-hidden="true">#</a> 一等值</h3><ul><li>可以将其赋给变量或存储在数组和对象等数据结构中</li><li>可以将其传递给函数</li><li>可以从函数中返回它们</li></ul><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h2><blockquote><p>名词，指的是函数和引用环境</p></blockquote><ul><li>局部变量：在函数体内部定义的变量，<strong>包括所有的形参</strong></li><li>自由变量：不在本地定义的变量（不是在本地声明的，没有绑定到任何值）</li><li>对于函数体内的变量，如果它既不是在本地定义的，又不是全局变量， 便可肯定它来自包含当前函数的其他 函数，可从环境中获取其值</li><li>包含自由变量的函数与为所有这些自由变量提供了变量绑定的环境一起，被称为闭包</li><li>并非只能通过从<code>函数返回函数来创建闭包</code>，如果<code>函数使用了自由变量，则每当你在创建该函数的上下文外面执行它时，都将创建一个闭包</code></li><li>将 <code>函数传递给函数时，也将创建闭包</code>。在这种情况下，传递的函数将在完全不同于定义它的上下文中执行</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> justAVar <span class="token operator">=</span> <span class="token string">&quot;Oh, don&#39;t you worry about it, I&#39;m GLOBAL&quot;</span>
<span class="token keyword">function</span> <span class="token function">whereAreYou</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> justAVar <span class="token operator">=</span> <span class="token string">&#39;Just an every day LOCAL&#39;</span>
  <span class="token keyword">function</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> justAVar
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> innerFunction <span class="token operator">=</span> <span class="token function">whereAreYou</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token comment">// A：Oh, don&#39;t you worry about it, I&#39;m GLOBAL</span>
<span class="token comment">// B：Just an every day LOCAL</span>

<span class="token keyword">var</span> justAVar <span class="token operator">=</span> <span class="token string">&quot;Oh, don&#39;t you worry about it, I&#39;m GLOBAL&quot;</span>
<span class="token keyword">function</span> <span class="token function">whereAreYou</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> justAVar <span class="token operator">=</span> <span class="token string">&#39;Just an every day LOCAL&#39;</span>
  <span class="token keyword">function</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> justAVar
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> inner
<span class="token punctuation">}</span>
<span class="token keyword">var</span> innerFunction <span class="token operator">=</span> <span class="token function">whereAreYou</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token comment">// A：Oh, don&#39;t you worry about it, I&#39;m GLOBAL</span>
<span class="token comment">// B：Just an every day LOCAL</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="构造函数工作原理" tabindex="-1"><a class="header-anchor" href="#构造函数工作原理" aria-hidden="true">#</a> 构造函数工作原理</h2><ol><li><code>new</code> 首先创建一个空对象</li><li>接下来，<code>new</code> 设置 <code>this</code>，使其指向这个对象</li><li>设置 <code>this</code> 后，调用函数构造函数 <code>Person</code> 并将实参进行传递</li><li>执行构造函数 <code>Person</code> 代码，给新创建的 <code>this</code> 对象的属性赋值</li><li><code>Person</code> 函数执行完毕后，运算符 <code>new</code> 返回 <code>this</code>（自动返回，武学在代码中显式返回），指向新创建的对象的引用 （构造函数返回值，除非返回的是 <code>this</code>）</li></ol><ul><li><p>构造函数名采用驼峰命名法，并且首字母要大写（约定俗成）</p></li><li><p>使用构造函数创建的对象时，<code>this</code> 被设置为一个引用，指向正在创建的新对象，因此构造函数的所有代码针对的都是这个新对象</p></li><li><p>对象创建后，当对其调用方法时，<code>this</code> 被设置为方法被调用的对象，因此，在方法中，<code>this</code> 总是表示方法被调用的对象</p></li></ul><blockquote><p>在任何情况下，this 都指向原始对象即方法被调 用的对象，即便该方法位于原型中也是如此</p></blockquote>`,24);function c(l,p){return s(),a("div",null,[e(" more "),t])}const r=n(i,[["render",c],["__file","1000.问题记录（待合并）.html.vue"]]);export{r as default};
