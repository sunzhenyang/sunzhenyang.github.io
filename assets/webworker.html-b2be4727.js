const e=JSON.parse(`{"key":"v-539dfee4","path":"/technology/javascript/bom/webworker.html","title":"Web Worker","lang":"zh-CN","frontmatter":{"title":"Web Worker","icon":"article","category":["javascript"],"article":false,"tag":["javascript"],"copyright":"Copyright by 阮一峰","description":"概述 JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。 Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务可以交由 Worker 线程执行，主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。","head":[["meta",{"property":"og:url","content":"https://codemake.fun/technology/javascript/bom/webworker.html"}],["meta",{"property":"og:site_name","content":"Yang's Blog"}],["meta",{"property":"og:title","content":"Web Worker"}],["meta",{"property":"og:description","content":"概述 JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。 Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务可以交由 Worker 线程执行，主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。"}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-01-11T09:12:15.000Z"}],["meta",{"property":"article:tag","content":"javascript"}],["meta",{"property":"article:modified_time","content":"2023-01-11T09:12:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"Web Worker\\",\\"description\\":\\"概述 JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。 Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务可以交由 Worker 线程执行，主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。\\"}"]]},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"基本用法","slug":"基本用法","link":"#基本用法","children":[{"level":3,"title":"主线程","slug":"主线程","link":"#主线程","children":[]},{"level":3,"title":"Worker 线程","slug":"worker-线程","link":"#worker-线程","children":[]},{"level":3,"title":"Worker 加载脚本","slug":"worker-加载脚本","link":"#worker-加载脚本","children":[]},{"level":3,"title":"错误处理","slug":"错误处理","link":"#错误处理","children":[]},{"level":3,"title":"关闭 Worker","slug":"关闭-worker","link":"#关闭-worker","children":[]}]},{"level":2,"title":"数据通信","slug":"数据通信","link":"#数据通信","children":[]},{"level":2,"title":"同页面的 Web Worker","slug":"同页面的-web-worker","link":"#同页面的-web-worker","children":[]},{"level":2,"title":"实例：Worker 线程完成轮询","slug":"实例-worker-线程完成轮询","link":"#实例-worker-线程完成轮询","children":[]},{"level":2,"title":"实例： Worker 新建 Worker","slug":"实例-worker-新建-worker","link":"#实例-worker-新建-worker","children":[]},{"level":2,"title":"API","slug":"api","link":"#api","children":[{"level":3,"title":"主线程","slug":"主线程-1","link":"#主线程-1","children":[]},{"level":3,"title":"Worker 线程","slug":"worker-线程-1","link":"#worker-线程-1","children":[]}]}],"git":{"createdTime":1673428335000,"updatedTime":1673428335000,"contributors":[{"name":"sunzhenyang","email":"874530670@qq.com","commits":1}]},"readingTime":{"minutes":9.23,"words":2770},"filePathRelative":"technology/javascript/bom/webworker.md","localizedDate":"2023年1月11日","excerpt":"<h2> 概述</h2>\\n<p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p>\\n<p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务可以交由 Worker 线程执行，主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。</p>","autoDesc":true}`);export{e as data};
