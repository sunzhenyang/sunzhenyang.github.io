import{_ as l,P as i,Q as t,Z as d,$ as a,a0 as e,a1 as c,a2 as n,C as o}from"./framework-f3782457.js";const p={},r=n(`<h2 id="面向对象" tabindex="-1"><a class="header-anchor" href="#面向对象" aria-hidden="true">#</a> 面向对象</h2><ul><li>类是模子，确定对象将会拥有的特征（属性）和行为（方法）</li><li>对象是类的实例表现</li><li>类是对象的类型</li><li>对象是特定类型的数据</li><li>一个类中可以声明多个 Class，但最多只能有一个被标记为 <code>public</code>，且要加在和文件名同名的 Class 上</li></ul><h3 id="类" tabindex="-1"><a class="header-anchor" href="#类" aria-hidden="true">#</a> 类</h3><blockquote><p>抽象的概念，类似与模板，具有相同属性和方法的一组对象的集合</p></blockquote><h4 id="包" tabindex="-1"><a class="header-anchor" href="#包" aria-hidden="true">#</a> 包</h4><ul><li><p>一个包中不能存在同名类</p></li><li><p><code>package + 包名</code>：指明该文件中定义的类所在的包，一个 java 文件中只能有一条 <code>package</code> 语句</p></li><li><p>java 文件中书写顺序：<code>package</code> - <code>import</code> - <code>class</code></p></li><li><p>创建包：域名倒序 + 模块 + 功能</p></li><li><p>导入包</p><ul><li>分别以 <code>*</code> 和 指定类名 进行导入，以类名导入优先级最高</li></ul></li><li><p>一个 Java 文件中可以存在多个类，多个接口，但是只能存在一个 <code>public</code> 修饰的类或接口，且此时文件名需要与 <code>public</code> 修饰的类或者接口同名</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 加载指定包下的所有直接允许访问的类，无法导入其子包中的类</span>
<span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>animal<span class="token punctuation">.</span></span><span class="token operator">*</span>

<span class="token comment">// 加载指定包下的指定类</span>
<span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>animal<span class="token punctuation">.</span></span><span class="token class-name">Cat</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="常用系统包" tabindex="-1"><a class="header-anchor" href="#常用系统包" aria-hidden="true">#</a> 常用系统包</h4>`,8),u=a("thead",null,[a("tr",null,[a("th",null,"包名"),a("th",null,"描述")])],-1),h=a("tr",null,[a("td",null,"java.lang"),a("td",null,[e("包含 java 语言基础的类，该包在系统加载时"),a("strong",null,"默认导入")])],-1),k=a("tr",null,[a("td",null,"java.util"),a("td",null,"包含 java 语言种常用工具，如：Scanner、Random")],-1),v={href:"http://java.io",target:"_blank",rel:"noopener noreferrer"},b=a("td",null,"包含输入输出相关功能的类，如：File、InputStream",-1),m=n(`<h4 id="构造方法" tabindex="-1"><a class="header-anchor" href="#构造方法" aria-hidden="true">#</a> 构造方法</h4><blockquote><p>用于生成并初始化对象，针对不同的初始化状态，设置不同参数的构造方法</p></blockquote><p>格式：<code>访问修饰符 类名(参数列表){ *** }</code></p><ul><li>方法名与类名相同，包括大小写</li><li>没有返回值，也不能用 <code>void</code> 修饰</li><li>只能在对象实例化（ <code>new</code> ）时调用，不能通过对象名、类名等其它形式调用</li><li>在非构造方法中，智能结合对象实例化操作被调用，不能通过方法名被访问</li><li>当没有指定构造方法时，编译系统会自动添加无参无反的构造方法</li><li>当有指定构造方法，无论是有参、无参的构造方法，编译器都不会自动添加无参的构造方法</li><li>一个类中可以有多个构造方法，多个构造方法之间可以使用 <code>this()</code> 进行调用 <ul><li>带参时需按顺序传入设定的参数</li><li>调用动作必须在构造函数的第一行</li><li>一个构造方法中只能调用一个构造方法</li><li>不能在类中普通成员方法内通过 <code>this()</code> 调用构造方法</li></ul></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Monkey</span><span class="token punctuation">{</span>
    <span class="token comment">// 构造方法</span>
    <span class="token keyword">public</span> <span class="token class-name">Monkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="成员属性" tabindex="-1"><a class="header-anchor" href="#成员属性" aria-hidden="true">#</a> 成员属性</h4><ul><li>有默认值</li></ul><table><thead><tr><th>数据类型</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>字节型</td><td>0</td></tr><tr><td>short</td><td>短整型</td><td>0</td></tr><tr><td>int</td><td>整型</td><td>0</td></tr><tr><td>long</td><td>长整型</td><td>0</td></tr><tr><td>float</td><td>单精度浮点型</td><td>0.0</td></tr><tr><td>double</td><td>双精度浮点型</td><td>0.0</td></tr><tr><td>char</td><td>字符型</td><td>空字符</td></tr><tr><td>String</td><td>字符串型</td><td>null</td></tr><tr><td>boolean</td><td>布尔型</td><td>false</td></tr></tbody></table><h4 id="成员方法" tabindex="-1"><a class="header-anchor" href="#成员方法" aria-hidden="true">#</a> 成员方法</h4><blockquote><p>根据类型所需任意功能，进行方法设置</p></blockquote><p>格式：<code>访问修饰符 返回值类型 方法名(参数列表){ *** }</code></p><ul><li>方法内定义的局部变量只能在方法里使用</li><li>方法内不能定义静态成员</li><li>不能使用 <code>public</code>、<code>protected</code>、<code>private</code> 修饰</li></ul><h4 id="this-关键字" tabindex="-1"><a class="header-anchor" href="#this-关键字" aria-hidden="true">#</a> this 关键字</h4><ul><li>代表当前对象本身，可以理解为：指向当前对象的一个引用</li><li>可用于调用成员属性、成员方法、构造方法，也可以当做参数进行方法传参以及方法传值</li><li>大部分时候，类的方法中访问成员属性时无需使用 <code>this</code>，但如果方法里存在局部变量和成员属性同名，但程序又需要在该方法里访问成员属性时，则必须使用 <code>this</code> 进行调用</li><li>类的成员方法访问同类中其他成员方法时，<code>this</code> 关键字可加可不加，效果相同</li><li>静态方法中不可使用 <code>this</code></li><li><code>this()</code> 只能在构造函数第一行，不能与 <code>super()</code> 共存</li></ul><h4 id="static-关键字" tabindex="-1"><a class="header-anchor" href="#static-关键字" aria-hidden="true">#</a> static 关键字</h4><h5 id="静态成员" tabindex="-1"><a class="header-anchor" href="#静态成员" aria-hidden="true">#</a> 静态成员</h5><blockquote><p>被 <code>static</code> 修饰的成员变量，通常被称为静态成员、静态属性、类成员、全局属性等，方便在没有创建对象的情况下进行某些操作</p></blockquote><ul><li><p>属于整个类，由类进行维护，仅在类初次加载时会被初始化，在类销毁时回收</p></li><li><p>通过该类实例化的所有对象都共享类中的静态资源，任一对象中静态资源的修改都将影响所有对象</p></li><li><p>由于静态成员在类加载期间就已经完成初始化，存储在 Java Heap（JDK7.0 之前存储在方法区）中静态存储区，因此优先于对象而存在，可以通过类名和对象名两种方式访问</p><ul><li><code>类.成员</code></li><li><code>对象.成员</code></li></ul></li><li><p>可以将频繁调用的公共信息、期望加快运行效率的成员设置为静态。但需注意，由于其生命周期长，即资源占用周期长，要慎用。</p></li></ul><h5 id="静态方法" tabindex="-1"><a class="header-anchor" href="#静态方法" aria-hidden="true">#</a> 静态方法</h5><blockquote><p>被 <code>static</code> 修饰的成员方法，通常被称为静态方法、类方法、全局方法等</p></blockquote><ul><li><p>与静态成员类似，静态方法属于整个类，由类进行维护，优先对象而存在，因此可以通过类名和对象名两种方式访问</p></li><li><p>静态方法中不能直接访问同一个类中的非静态成员，只能直接调用用一个类中的静态成员</p></li><li><p>不允许在方法内部定义静态局部变量</p></li></ul><h5 id="代码块" tabindex="-1"><a class="header-anchor" href="#代码块" aria-hidden="true">#</a> 代码块</h5><blockquote><p>执行优先级：<code>静态代码块 &gt; 构造代码块 &gt; 构造方法</code></p></blockquote><ul><li>普通代码块 <ul><li>定义在方法内部，用 <code>{}</code> 括起来的代码段</li><li>可以在方法中出现多次，按顺序在方法调用时执行，作用域独立</li><li><strong>适用于在方法内进行代码功能拆分</strong></li></ul></li><li>构造代码块 <ul><li>没有被 <code>static</code> 修饰的，定义在类内部，用 <code>{}</code> 括起来的代码段</li><li>可以在类中出现多次，按顺序在每个对象实例化时执行</li><li>优先于构造方法执行，晚于静态方法执行</li><li>可以在构造代码块中直接操作静态和非静态成员</li><li><strong>多适用于类中每个对象产生时都需要执行的功能封装。与构造方法的区别在于，构造方法是在 <code>new</code> 执行时有选择性的调用带参或者无参构造，而构造代码块则是在每个对象实例化时都一定会执行</strong></li></ul></li><li>静态代码块 <ul><li>被 <code>static</code> 修饰的，定义在类内部，用 <code>{}</code> 括起来的代码段</li><li>只能出现在类内，不能出现在方法内</li><li>可以出现多次，按顺序在类加载时执行</li><li>无论该类实例化多少对象，只执行一次</li><li>不能在静态代码块中声明静态成员，可以声明非静态成员，静态代码块中声明的成员，在外部无法访问</li><li>不能在静态代码块中直接对非静态成员赋值</li><li><strong>基于性能优化的考量，多适用于需要在项目启动时执行一次的场景，比如项目整体资源加载等</strong></li></ul></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 普通代码块</span>
<span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 构造代码块</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Book</span><span class="token punctuation">{</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 静态代码块</span>
<span class="token keyword">static</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="对象" tabindex="-1"><a class="header-anchor" href="#对象" aria-hidden="true">#</a> 对象</h3><blockquote><p>用来描述客观事物的一个实体</p></blockquote><ul><li>声明对象在 <strong>栈</strong> 中，实例化对象在 <strong>堆</strong> 中</li></ul><h3 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类" aria-hidden="true">#</a> 抽象类</h3><ul><li><p>为子类提供一个公共类型，封装子类中的重复内容（成员变量和方法）</p></li><li><p>抽象类不能实例化，只能通过引用指向子类实例（向上转型）</p></li><li><p>含有抽象方法的类一定是抽象类，但是抽象类中可以没有抽象方法</p></li><li><p>一个类继承抽象类之后，必须实现其所有的抽象方法，否则也需要设置为抽象类，不同子类对父类的抽象方法可以有不同的实现</p></li><li><p>子类只能通过 <code>extends</code> 继承一个抽象父类</p></li><li><p>抽象类中的静态成员和方法可以被子类继承应用</p></li><li><p>类中抽象方法必须加 <code>abstract</code> 关键字</p></li><li><p>抽象方法支持 <code>public</code> 、<code>protected</code> 和默认访问权限</p></li><li><p>可借由父子关系限制子类设计的随意性，在一定程度上避免了无意义父类的实例化</p></li><li><p>应用场景：某个父类只知道其子类应该包含怎样的方法，但无法知道子类如何实现这些方法</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="抽象方法" tabindex="-1"><a class="header-anchor" href="#抽象方法" aria-hidden="true">#</a> 抽象方法</h4><ul><li><p>抽象方法必须定义在抽象类中</p></li><li><p>抽象方法不能有方法体</p></li><li><p>子类必须重写父类抽象方法（如果不想重写父类方法，则需要将子类也设置为抽象类）</p></li><li><p>抽象方法不能使用 <code>static</code>、<code>final</code>、<code>private</code> 修饰</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,34);function g(_,f){const s=o("ExternalLinkIcon");return i(),t("div",null,[d(" more "),r,a("table",null,[u,a("tbody",null,[h,k,a("tr",null,[a("td",null,[a("a",v,[e("java.io"),c(s)])]),b])])]),m])}const j=l(p,[["render",g],["__file","面向对象.html.vue"]]);export{j as default};
