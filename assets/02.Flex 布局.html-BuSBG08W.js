import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,o as c,c as r,a as d,b as e,d as i,e as o,f as n}from"./app-DdwQwFQ1.js";const s={},h=n('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><blockquote><p><code>display: flex</code>： 意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性</p></blockquote><blockquote><p><code>display: inline-flex</code>： 创建一个弹性容器，行为类似于 <code>inline-block</code> 元素。它会跟其他行内元素一起流式排列，但不会自动增长到 100%的 宽度。内部的弹性子元素跟使用 display: flex 创建的 Flexbox 里的弹性子元素行为 一样。在实际开发时，很少用到 display: inline-flex。</p></blockquote><h3 id="特性" tabindex="-1"><a class="header-anchor" href="#特性"><span>特性</span></a></h3><ul><li>消除块级元素特性（之后所有设置的 <code>display: block;</code> 都是无效的）</li><li>设为 <code>flex</code> 布局以后，子元素的 <code>float</code> 、<code>clear</code> 和 <code>vertical-align</code> 等属性将失效</li><li>采用 <code>flex</code> 布局的元素，称为 flex 容器，简称 <strong>容器</strong>，所有子元素自动成为容器成员，称为 flex 项目，简称 <strong>项目</strong></li><li>容器默认存在两根轴，水平的主轴和与其垂直的交叉轴</li></ul><h3 id="空间" tabindex="-1"><a class="header-anchor" href="#空间"><span>空间</span></a></h3><ul><li>主轴的开始位置（与边框的交叉点）叫做 <code>main start</code>，结束位置叫做 <code>main end</code></li><li>交叉轴的开始位置叫做 <code>cross start</code>，结束位置叫做 <code>cross end</code></li><li>项目默认沿主轴排列</li><li>单个项目占据的主轴空间叫做 <code>main size</code>，占据的交叉轴空间叫做 <code>cross size</code></li></ul><figure><img src="https://cdn.jsdelivr.net/gh/sunzhenyang/blog-vuepress-img/img/20210426210125.png" alt="bg2015071004" tabindex="0" loading="lazy"><figcaption>bg2015071004</figcaption></figure><h2 id="容器属性" tabindex="-1"><a class="header-anchor" href="#容器属性"><span>容器属性</span></a></h2><h3 id="flex-direction" tabindex="-1"><a class="header-anchor" href="#flex-direction"><span>flex-direction</span></a></h3><ul><li>定义主轴的方向（即项目的排列方向） <ul><li><code>row</code>（默认值）：主轴水平方向，起点在左端</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端</li><li><code>column</code>：主轴为垂直方向，起点在上沿</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿</li></ul></li></ul><h3 id="flex-wrap" tabindex="-1"><a class="header-anchor" href="#flex-wrap"><span>flex-wrap</span></a></h3><ul><li>定义如果一条轴线排不下，如何换行（项目默认都排在一条线轴线上） <ul><li><code>nowrap</code>（默认）：不换行（子元素按比例平均分配）</li><li><code>wrap</code>：换行，第一行在上方</li><li><code>swrap-reverse</code>：换行，第一行在下方(只是行的顺序变化，元素在行内的顺序不变)</li></ul></li></ul><h3 id="flex-flow" tabindex="-1"><a class="header-anchor" href="#flex-flow"><span>flex-flow</span></a></h3><ul><li><code>flex-direction</code> 属性和 <code>flex-wrap</code> 属性的简写形式 <ul><li>默认值为 <code>row nowrap</code></li><li>写法：<code>flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;</code></li></ul></li></ul><h3 id="justify-content" tabindex="-1"><a class="header-anchor" href="#justify-content"><span>justify-content</span></a></h3><ul><li>定义项目在主轴上的对齐方式 <ul><li><code>flex-start</code>（默认值）：向主轴起点方向对齐</li><li><code>flex-end</code>：向主轴终点方向对齐</li><li><code>center</code>： 向主轴居中对齐</li><li><code>space-between</code>：由主轴两端对齐，项目之间的间隔都相等</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li></ul></li></ul><h3 id="align-items" tabindex="-1"><a class="header-anchor" href="#align-items"><span>align-items</span></a></h3><ul><li>定义项目在交叉轴上如何对齐 <ul><li><code>flex-start</code>：向交叉轴起点方向对齐</li><li><code>flex-end</code>：向交叉轴终点方向对齐</li><li><code>center</code>：向交叉轴的中点对齐</li><li><code>baseline</code>: 项目的第一行文字的基线对齐</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</li></ul></li></ul><h3 id="align-content" tabindex="-1"><a class="header-anchor" href="#align-content"><span>align-content</span></a></h3><ul><li>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用 <ul><li><code>flex-start</code>：向交叉轴起点方向对齐</li><li><code>flex-end</code>：向交叉轴终点方向对齐</li><li><code>center</code>：向交叉轴的中点对齐</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴</li></ul></li></ul><h2 id="项目属性" tabindex="-1"><a class="header-anchor" href="#项目属性"><span>项目属性</span></a></h2><h3 id="order" tabindex="-1"><a class="header-anchor" href="#order"><span>Order</span></a></h3><ul><li>定义项目的排列顺序。数值越小，排列越靠前</li><li>默认为0（可为负值）</li></ul><h3 id="flex-grow" tabindex="-1"><a class="header-anchor" href="#flex-grow"><span>flex-grow</span></a></h3><ul><li>定义项目的放大比例 <ul><li>默认为 <code>0</code>，即如果存在剩余空间，也不放大</li><li>如果所有项目的 <code>flex-grow</code> 属性都为 <code>1</code>，则它们将等分<strong>剩余空间</strong>（如果有的话）</li><li>如果一个项目的 <code>flex-grow</code> 属性为 <code>2</code>，其他项目都为 <code>1</code>，则前者占据的<strong>剩余空间</strong>将比其他项多一倍</li></ul></li></ul><h3 id="flex-shrin" tabindex="-1"><a class="header-anchor" href="#flex-shrin"><span>flex-shrin</span></a></h3><ul><li>定义了项目的缩小比例 <ul><li>默认为 <code>1</code>，即如果空间不足，该项目将缩小（无负值）</li><li>如果所有项目的 <code>flex-shrink</code> 属性都为 <code>1</code>，当空间不足时，都将等比例缩小</li><li>如果一个项目的 <code>flex-shrink</code> 属性为 <code>0</code>，其他项目都为 <code>1</code>，则空间不足时，前者不缩小</li></ul></li></ul><h3 id="flex-basis" tabindex="-1"><a class="header-anchor" href="#flex-basis"><span>flex-basis</span></a></h3><ul><li>定义了在分配多余空间之前，项目占据的主轴空间（main size） <ul><li>浏览器根据这个属性，计算主轴是否有多余空间</li><li>默认值为 <code>auto</code>，即项目的本来大小</li><li>它可以设为跟 <code>width</code> 或 <code>height</code> 属性一样的值（比如350px），则项目将占据固定空间</li></ul></li></ul><h3 id="flex" tabindex="-1"><a class="header-anchor" href="#flex"><span>flex</span></a></h3><ul><li>是 <code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code> 的简写 <ul><li>默认值为 <code>0 1 auto</code>，后两个属性可选</li><li>该属性有两个快捷值：<code>auto (1 1 auto)</code> 和 <code>none (0 0 auto)</code></li><li>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值</li></ul></li></ul><h3 id="align-self" tabindex="-1"><a class="header-anchor" href="#align-self"><span>align-self</span></a></h3><ul><li>允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 <ul><li>默认值为 <code>auto</code>，表示继承父元素的 <code>align-items</code> 属性，如果没有父元素，则等同于 <code>stretch</code></li><li>写法：<code>align-self: auto | flex-start | flex-end | center | baseline | stretch</code></li><li>该属性可能取 6 个值，除了 <code>auto</code>，其他都与 <code>align-items</code> 属性完全一致</li></ul></li></ul><br><h2 id="其他布局方式" tabindex="-1"><a class="header-anchor" href="#其他布局方式"><span>其他布局方式</span></a></h2><h3 id="flex-布局教程-语法篇" tabindex="-1"><a class="header-anchor" href="#flex-布局教程-语法篇"><span>Flex 布局教程：语法篇</span></a></h3>',37),f={href:"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html",target:"_blank",rel:"noopener noreferrer"},u=e("h3",{id:"css-grid-网格布局教程",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#css-grid-网格布局教程"},[e("span",null,"CSS Grid 网格布局教程")])],-1),p={href:"http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html",target:"_blank",rel:"noopener noreferrer"},g=e("h3",{id:"只要一行代码-实现五种-css-经典布局",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#只要一行代码-实现五种-css-经典布局"},[e("span",null,"只要一行代码，实现五种 CSS 经典布局")])],-1),x={href:"http://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html",target:"_blank",rel:"noopener noreferrer"},m=n("<ul><li>空间居中布局 <blockquote><p>不管容器的大小，项目总是占据中心点</p></blockquote></li><li>并列式布局 <blockquote><p>多个项目并列，如果宽度不够，放不下的项目就自动折行</p></blockquote></li><li>两栏式布局 <blockquote><p>一个边栏，一个主栏。边栏始终存在，主栏根据设备宽度，变宽或者变窄</p></blockquote></li><li>三明治布局 <blockquote><p>页面在垂直方向上，分成三部分：页眉、内容区、页脚。</p></blockquote></li><li>圣杯布局 <blockquote><p>最常用的布局，所以被比喻为圣杯。它将页面分成五个部分，除了页眉和页脚，内容区分成左边栏、主栏、右边栏。</p></blockquote></li></ul><blockquote><p>参考</p></blockquote>",2),b={href:"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html",target:"_blank",rel:"noopener noreferrer"},w={href:"https://www.ituring.com.cn/book/2583",target:"_blank",rel:"noopener noreferrer"};function k(_,y){const l=a("ExternalLinkIcon");return c(),r("div",null,[d(" more "),h,e("p",null,[e("a",f,[i("http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html"),o(l)])]),u,e("p",null,[e("a",p,[i("http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html"),o(l)])]),g,e("p",null,[e("a",x,[i("http://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html"),o(l)])]),m,e("ul",null,[e("li",null,[e("a",b,[i("Flex 布局教程：语法篇"),o(l)])]),e("li",null,[e("a",w,[i("《深入解析CSS》"),o(l)])])])])}const S=t(s,[["render",k],["__file","02.Flex 布局.html.vue"]]),F=JSON.parse(`{"path":"/fe/css/knowledge/02.Flex%20%E5%B8%83%E5%B1%80.html","title":"Flex 布局","lang":"zh-CN","frontmatter":{"title":"Flex 布局","icon":"creative","category":["CSS"],"tag":["css"],"head":[["meta",{"property":"og:url","content":"https://codemake.fun/fe/css/knowledge/02.Flex%20%E5%B8%83%E5%B1%80.html"}],["meta",{"property":"og:site_name","content":"Yang's Blog"}],["meta",{"property":"og:title","content":"Flex 布局"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/sunzhenyang/blog-vuepress-img/img/20210426210125.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-01-11T09:12:15.000Z"}],["meta",{"property":"article:author","content":"Yang"}],["meta",{"property":"article:tag","content":"css"}],["meta",{"property":"article:modified_time","content":"2023-01-11T09:12:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Flex 布局\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/sunzhenyang/blog-vuepress-img/img/20210426210125.png\\"],\\"dateModified\\":\\"2023-01-11T09:12:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yang\\",\\"url\\":\\"https://codemake.fun/\\",\\"email\\":\\"874530670@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[{"level":3,"title":"特性","slug":"特性","link":"#特性","children":[]},{"level":3,"title":"空间","slug":"空间","link":"#空间","children":[]}]},{"level":2,"title":"容器属性","slug":"容器属性","link":"#容器属性","children":[{"level":3,"title":"flex-direction","slug":"flex-direction","link":"#flex-direction","children":[]},{"level":3,"title":"flex-wrap","slug":"flex-wrap","link":"#flex-wrap","children":[]},{"level":3,"title":"flex-flow","slug":"flex-flow","link":"#flex-flow","children":[]},{"level":3,"title":"justify-content","slug":"justify-content","link":"#justify-content","children":[]},{"level":3,"title":"align-items","slug":"align-items","link":"#align-items","children":[]},{"level":3,"title":"align-content","slug":"align-content","link":"#align-content","children":[]}]},{"level":2,"title":"项目属性","slug":"项目属性","link":"#项目属性","children":[{"level":3,"title":"Order","slug":"order","link":"#order","children":[]},{"level":3,"title":"flex-grow","slug":"flex-grow","link":"#flex-grow","children":[]},{"level":3,"title":"flex-shrin","slug":"flex-shrin","link":"#flex-shrin","children":[]},{"level":3,"title":"flex-basis","slug":"flex-basis","link":"#flex-basis","children":[]},{"level":3,"title":"flex","slug":"flex","link":"#flex","children":[]},{"level":3,"title":"align-self","slug":"align-self","link":"#align-self","children":[]}]},{"level":2,"title":"其他布局方式","slug":"其他布局方式","link":"#其他布局方式","children":[{"level":3,"title":"Flex 布局教程：语法篇","slug":"flex-布局教程-语法篇","link":"#flex-布局教程-语法篇","children":[]},{"level":3,"title":"CSS Grid 网格布局教程","slug":"css-grid-网格布局教程","link":"#css-grid-网格布局教程","children":[]},{"level":3,"title":"只要一行代码，实现五种 CSS 经典布局","slug":"只要一行代码-实现五种-css-经典布局","link":"#只要一行代码-实现五种-css-经典布局","children":[]}]}],"git":{"createdTime":1673428335000,"updatedTime":1673428335000,"contributors":[{"name":"sunzhenyang","email":"874530670@qq.com","commits":1}]},"readingTime":{"minutes":5.13,"words":1539},"filePathRelative":"fe/css/knowledge/02.Flex 布局.md","localizedDate":"2023年1月11日","excerpt":""}`);export{S as comp,F as data};
