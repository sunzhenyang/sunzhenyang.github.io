import{_ as l,P as i,Q as o,Z as t,$ as e,a0 as a,a2 as c}from"./framework-f3782457.js";const r={},d=e("h2",{id:"方法",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#方法","aria-hidden":"true"},"#"),a(" 方法")],-1),s=e("blockquote",null,[e("p",null,"语法格式")],-1),n=e("p",{方法体:""},"访问修饰福 返回类型 方法名(参数列表)",-1),h=c('<blockquote><p>根据方法是否带参数、是否返回值，分为四类</p></blockquote><ul><li>无参无返回值方法</li><li>无参带返回值方法</li><li>带参无返回值方法</li><li>带参带返回值方法</li></ul><h3 id="方法重载" tabindex="-1"><a class="header-anchor" href="#方法重载" aria-hidden="true">#</a> 方法重载</h3><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数 <strong>类型不同</strong> 或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong>，与方法参数名无关</li><li>可变参数作为参数的重载方法不会被优先调用</li></ul><h3 id="方法重写" tabindex="-1"><a class="header-anchor" href="#方法重写" aria-hidden="true">#</a> 方法重写</h3><ul><li>在子类中定义，重写父类中的方法</li><li>方法名，参数列表（类型、个数、顺序）与父类完全一致，与方法参数名无关</li><li>方法的返回值和访问修饰符是允许有变化的 <ul><li>如果父类方法的返回值是 <code>void</code> 或 基本数据类型，则要求子类方法重写时返回类型与父类完全一致</li><li>如果父类方法的返回值是引用类型，则要求子类方法重写时返回类型与父类一致或为父类类型的子类</li><li>访问修饰符：子类重写方法的访问修饰符访问范围要大于等与父类的访问范围</li></ul></li><li><code>final</code> 修饰的方法不允许被重写</li><li><code>static</code> 修饰的方法 <ul><li>加了 <code>@Override</code> 后不允许被重写，不加则被视为子类的静态方法</li></ul></li></ul>',6);function u(_,f){return i(),o("div",null,[t(" more "),d,s,n,h])}const p=l(r,[["render",u],["__file","方法.html.vue"]]);export{p as default};
