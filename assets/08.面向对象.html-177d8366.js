import{_ as a,Q as e,S as n,$ as s,a3 as t}from"./framework-2ed98ecf.js";const i={},d=t(`<h2 id="类和对象" tabindex="-1"><a class="header-anchor" href="#类和对象" aria-hidden="true">#</a> 类和对象</h2><ul><li>类是模子，确定对象将会拥有的特征（属性）和行为（方法），是对象的类型</li><li>对象是类的实例表现，是特定类型的数据，声明对象在 <strong>栈</strong> 中，实例化对象在 <strong>堆</strong> 中</li><li>一个 Java 文件中可以存在多个类，多个接口，但是只能存在一个 <code>public</code> 修饰的类或接口，且此时文件名需要与 <code>public</code> 修饰的类或者接口同名</li></ul><h2 id="包" tabindex="-1"><a class="header-anchor" href="#包" aria-hidden="true">#</a> 包</h2><h3 id="命名规范" tabindex="-1"><a class="header-anchor" href="#命名规范" aria-hidden="true">#</a> 命名规范</h3><ul><li>由英文小写字母组成</li><li>创建包：域名倒序 + 模块 + 功能</li><li>一个包中不能存在同名类</li><li><code>package + 包名</code>：指明该文件中定义的类所在的包，一个 java 文件中只能有一条 <code>package</code> 语句</li><li>java 文件中书写顺序：<code>package</code> - <code>import</code> - <code>class</code></li><li>导入包：分别以 <code>*</code> 和 指定类名 进行导入，以类名导入优先级最高</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 加载指定包下的所有直接允许访问的类，无法导入其子包中的类</span>
<span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>animal<span class="token punctuation">.</span></span><span class="token operator">*</span>

<span class="token comment">// 加载指定包下的指定类（优先级最高）</span>
<span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>animal<span class="token punctuation">.</span></span><span class="token class-name">Cat</span>
  
<span class="token comment">// 在程序中直接加载类</span>
<span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>animal<span class="token punctuation">.</span></span>CatTest</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>animal<span class="token punctuation">.</span></span>CatTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="常用系统包" tabindex="-1"><a class="header-anchor" href="#常用系统包" aria-hidden="true">#</a> 常用系统包</h3><table><thead><tr><th>包名</th><th>描述</th></tr></thead><tbody><tr><td><code>java.lang</code></td><td>包含 java 语言基础的类，该包在系统加载时<strong>默认导入</strong></td></tr><tr><td><code>java.util</code></td><td>包含 java 语言种常用工具，如：Scanner、Random</td></tr><tr><td><code>java.io</code></td><td>包含输入输出相关功能的类，如：File、InputStream</td></tr></tbody></table><h2 id="构造方法" tabindex="-1"><a class="header-anchor" href="#构造方法" aria-hidden="true">#</a> 构造方法</h2><blockquote><p>用于生成并初始化对象，针对不同的初始化状态，设置不同参数的构造方法</p></blockquote><p>格式：<code>访问修饰符 类名(参数列表){ *** }</code></p><ul><li>方法名与类名相同，包括大小写</li><li>没有返回值，也不能用 <code>void</code> 修饰</li><li>只能在对象实例化（ <code>new</code> ）时调用，不能通过对象名、类名等其它形式调用</li><li>在非构造方法中，智能结合对象实例化操作被调用，不能通过方法名被访问</li><li>当没有指定构造方法时，编译系统会自动添加无参无反的构造方法</li><li><strong>当有指定构造方法，无论是有参、无参的构造方法，编译器都不会自动添加无参的构造方法</strong></li><li>一个类中可以包含多个构造方法，只要满足参数类型、顺序、个数不同即可，也称为 <strong>构造方法重载</strong></li><li>多个构造方法之间可以使用 <strong><code>this()</code></strong> 进行调用 <ul><li>带参时需按顺序传入设定的参数</li><li>调用动作必须在构造函数的第一行</li><li>一个构造方法中只能调用一个构造方法</li><li>不能在类中普通成员方法内通过 <code>this()</code> 调用构造方法</li><li>不能与 <code>super()</code> 共存</li></ul></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Monkey</span><span class="token punctuation">{</span>
    <span class="token comment">// 构造方法</span>
    <span class="token keyword">public</span> <span class="token class-name">Monkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="成员属性默认值" tabindex="-1"><a class="header-anchor" href="#成员属性默认值" aria-hidden="true">#</a> 成员属性默认值</h2><table><thead><tr><th>数据类型</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>字节型</td><td>0</td></tr><tr><td>short</td><td>短整型</td><td>0</td></tr><tr><td>int</td><td>整型</td><td>0</td></tr><tr><td>long</td><td>长整型</td><td>0</td></tr><tr><td>float</td><td>单精度浮点型</td><td>0.0</td></tr><tr><td>double</td><td>双精度浮点型</td><td>0.0</td></tr><tr><td>char</td><td>字符型</td><td>空字符</td></tr><tr><td>String</td><td>字符串型</td><td>null</td></tr><tr><td>boolean</td><td>布尔型</td><td>false</td></tr></tbody></table><h2 id="成员方法" tabindex="-1"><a class="header-anchor" href="#成员方法" aria-hidden="true">#</a> 成员方法</h2><blockquote><p>根据类型所需任意功能，进行方法设置</p></blockquote><p>格式：<code>访问修饰符 返回值类型 方法名(参数列表){ *** }</code></p><ul><li>方法内定义的局部变量只能在方法里使用</li><li>方法内不能定义静态成员</li><li>不能使用 <code>public</code>、<code>protected</code>、<code>private</code> 修饰</li></ul><h2 id="this-关键字" tabindex="-1"><a class="header-anchor" href="#this-关键字" aria-hidden="true">#</a> this 关键字</h2><ul><li>代表当前对象本身，可以理解为：指向当前对象的一个引用</li><li>可用于调用成员属性、成员方法、构造方法，也可以当做参数进行方法传参以及方法传值</li><li>大部分时候，类的方法中访问成员属性时无需使用 <code>this</code>，但如果方法里存在局部变量和成员属性同名，但程序又需要在该方法里访问成员属性时，则必须使用 <code>this</code> 进行调用</li><li>类的成员方法访问同类中其他成员方法时，<code>this</code> 关键字可加可不加，效果相同</li><li>静态方法中不可使用 <code>this</code></li></ul><h2 id="static-关键字" tabindex="-1"><a class="header-anchor" href="#static-关键字" aria-hidden="true">#</a> static 关键字</h2><h3 id="静态成员" tabindex="-1"><a class="header-anchor" href="#静态成员" aria-hidden="true">#</a> 静态成员</h3><blockquote><p>被 <code>static</code> 修饰的成员变量，通常被称为静态成员、静态属性、类成员、全局属性等，方便在没有创建对象的情况下进行某些操作</p></blockquote><ul><li><p>属于整个类，由类进行维护，仅在类初次加载时会被初始化，在类销毁时回收</p></li><li><p>通过该类实例化的所有对象都共享类中的静态资源，任一对象中静态资源的修改都将影响所有对象</p></li><li><p>由于静态成员在类加载期间就已经完成初始化，存储在 Java Heap（JDK7.0 之前存储在方法区）中静态存储区，因此优先于对象而存在，可以通过类名和对象名两种方式访问</p><ul><li><code>类.成员</code>（推荐）</li><li><code>对象.成员</code></li></ul></li><li><p>可以将频繁调用的公共信息、期望加快运行效率的成员设置为静态。但需注意，由于其生命周期长，即资源占用周期长，要慎用。</p></li></ul><h3 id="静态方法" tabindex="-1"><a class="header-anchor" href="#静态方法" aria-hidden="true">#</a> 静态方法</h3><blockquote><p>被 <code>static</code> 修饰的成员方法，通常被称为静态方法、类方法、全局方法等</p></blockquote><ul><li>与静态成员类似，静态方法属于整个类，由类进行维护，优先对象而存在，因此可以通过类名和对象名两种方式访问</li><li>静态方法中不能直接访问同一个类中的非静态成员，只能直接调用一个类中的静态成员</li><li>不允许在方法内部定义静态局部变量</li><li>静态方法中不能使用 <code>this</code></li><li>非静态方法可以通过 <code>类名.成员法</code> 或 <code>成员</code> 或 <code>this.成员</code> 的方式访问类内静态成员/静态方法</li><li>应用 <code>this.静态成员/静态方法</code> 时会出现警告，但不影响程序运行</li></ul><h2 id="代码块" tabindex="-1"><a class="header-anchor" href="#代码块" aria-hidden="true">#</a> 代码块</h2><blockquote><p>执行优先级：<code>静态代码块 &gt; 构造代码块 &gt; 构造方法</code></p></blockquote><h3 id="普通代码块" tabindex="-1"><a class="header-anchor" href="#普通代码块" aria-hidden="true">#</a> 普通代码块</h3><blockquote><p>定义在方法内部，用 <code>{}</code> 括起来的代码段</p></blockquote><ul><li>可以在方法中出现多次，按顺序在方法调用时执行，作用域独立</li><li><strong>适用于在方法内进行代码功能拆分</strong></li></ul><h3 id="构造代码块" tabindex="-1"><a class="header-anchor" href="#构造代码块" aria-hidden="true">#</a> 构造代码块</h3><blockquote><p>定义在类内部，没有被 <code>static</code> 修饰的，用 <code>{}</code> 括起来的代码段</p></blockquote><ul><li>可以在类中出现多次，按顺序在每个对象实例化时执行</li><li><strong>运行顺序（由早到晚）：<code>静态代码块</code> <code>构造代码块</code> <code>构造方法</code></strong></li><li>可以在构造代码块中直接操作静态和非静态成员</li><li><strong>多适用于类中每个对象产生时都需要执行的功能封装。与构造方法的区别在于，构造方法是在 <code>new</code> 执行时有选择性的调用带参或者无参构造，而构造代码块则是在每个对象实例化时都一定会执行</strong></li></ul><h3 id="静态代码块" tabindex="-1"><a class="header-anchor" href="#静态代码块" aria-hidden="true">#</a> 静态代码块</h3><blockquote><p>被 <code>static</code> 修饰的，定义在类内部，用 <code>{}</code> 括起来的代码段</p></blockquote><ul><li>只能出现在类内，不能出现在方法内</li><li>可以出现多次，按顺序在类加载时执行</li><li>无论该类实例化多少对象，只执行一次</li><li>不能在静态代码块中声明静态成员，可以声明非静态成员，静态代码块中声明的成员，在外部无法访问</li><li>不能在静态代码块中直接对非静态成员赋值</li><li><strong>基于性能优化的考量，多适用于需要在项目启动时执行一次的场景，比如项目整体资源加载等</strong></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 普通代码块</span>
<span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 构造代码块</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Book</span><span class="token punctuation">{</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 静态代码块</span>
<span class="token keyword">static</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类" aria-hidden="true">#</a> 抽象类</h2><h3 id="意义" tabindex="-1"><a class="header-anchor" href="#意义" aria-hidden="true">#</a> 意义</h3><ul><li>为子类提供一个公共类型，封装子类中的重复内容（成员变量和方法）</li><li>封装子类当中重复的内容（成员变量和方法）</li><li>可借由父子关系限制子类设计的随意性，在一定程度上避免了无意义父类的实例化</li></ul><h3 id="描述" tabindex="-1"><a class="header-anchor" href="#描述" aria-hidden="true">#</a> 描述</h3><ul><li>抽象类不能实例化，只能通过引用指向子类实例（向上转型）</li><li>含有抽象方法的类一定是抽象类，但是抽象类中可以没有抽象方法</li><li>一个类继承抽象类之后，必须实现其所有的抽象方法，否则也需要设置为抽象类，不同子类对父类的抽象方法可以有不同的实现</li><li>子类只能通过 <code>extends</code> 继承一个抽象父类</li><li>抽象类中的静态成员和方法可以被子类继承应用</li><li>应用场景：某个父类只知道其子类应该包含怎样的方法，但无法知道子类如何实现这些方法</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="抽象方法" tabindex="-1"><a class="header-anchor" href="#抽象方法" aria-hidden="true">#</a> 抽象方法</h3><ul><li><p>抽象方法必须定义在抽象类中</p></li><li><p>抽象方法必须加 <code>abstract</code> 关键字，并且不能有方法体</p></li><li><p>子类必须重写父类抽象方法（如果不想重写父类方法，则需要将子类也设置为抽象类）</p></li><li><p>支持 <code>public</code> 、<code>protected</code> 和默认访问权限</p></li><li><p>不能使用 <code>static</code>、<code>final</code>、<code>private</code> 修饰</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="基本原则-solid" tabindex="-1"><a class="header-anchor" href="#基本原则-solid" aria-hidden="true">#</a> 基本原则（SOLID）</h2><h3 id="单一职责原则-srp" tabindex="-1"><a class="header-anchor" href="#单一职责原则-srp" aria-hidden="true">#</a> 单一职责原则（SRP）</h3><blockquote><p>一个类应该只有一个发生变化的原因</p></blockquote><p>一个类（大到模块、小到方法）承担的职责越多，被复用的可能性就越小，而且当一个类承担的职责过多，就相当于把这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变，则可将它们封装在同一类中。</p><h3 id="开放封闭原则-ocp" tabindex="-1"><a class="header-anchor" href="#开放封闭原则-ocp" aria-hidden="true">#</a> 开放封闭原则（OCP）</h3><h3 id="里氏替换原则-lsp" tabindex="-1"><a class="header-anchor" href="#里氏替换原则-lsp" aria-hidden="true">#</a> 里氏替换原则（LSP）</h3><h3 id="接口分离原则-isp" tabindex="-1"><a class="header-anchor" href="#接口分离原则-isp" aria-hidden="true">#</a> 接口分离原则（ISP）</h3><h3 id="依赖倒置原则-dip" tabindex="-1"><a class="header-anchor" href="#依赖倒置原则-dip" aria-hidden="true">#</a> 依赖倒置原则（DIP）</h3>`,57);function l(c,o){return e(),n("div",null,[s(" more "),d])}const r=a(i,[["render",l],["__file","08.面向对象.html.vue"]]);export{r as default};
