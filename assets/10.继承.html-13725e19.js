import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as l,a as s,f as i}from"./app-e1714ab0.js";const e={},c=i(`<blockquote><p>一种类与类之间的关系，使用已存在的类的定义作为基础建立新类，新类（子类、派生类）的定义可以增加新的数据或新的功能，也可以用父类（基类）的功能，但<strong>不能选择性的继承父类</strong></p></blockquote><ul><li>子类会继承父类所有 <code>public</code> 类型的实例变量和方法，但不会继承父类所有的 <code>private</code> 类型变量和方法</li></ul><h2 id="初始化顺序" tabindex="-1"><a class="header-anchor" href="#初始化顺序" aria-hidden="true">#</a> 初始化顺序</h2><ul><li><p>父类静态成员 &gt; 子类静态成员 &gt; 父类对象构造 &gt; 子类对象构造</p></li><li><p>访问修饰符不影响成员加载顺序，跟书写位置有关</p></li></ul><h2 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h2><ul><li>利用代码复用</li><li>缩短开发周期</li><li>单继承：子类只能继承一个父类</li><li>父类的私有成员子类不可继承</li><li>父类的构造方法不允许被继承，不允许被重写</li><li>子类构造方法默认调用父类的无参构造</li></ul><h2 id="格式" tabindex="-1"><a class="header-anchor" href="#格式" aria-hidden="true">#</a> 格式</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="super" tabindex="-1"><a class="header-anchor" href="#super" aria-hidden="true">#</a> super</h2><blockquote><p>表示父类对象的引用</p></blockquote><ul><li><p>调用父类可访问的属性</p></li><li><p>调用父类方法</p></li><li><p>调用父类指定构造方法，要放在子类构造方法的 <strong>第一行</strong></p></li><li><p><strong>子类的构造过程中必须调用其父类的构造方法</strong></p></li><li><p>如果子类的构造方法中没有显示标注，则系统 <strong>默认调用父类的无参构造方法</strong></p><ul><li>此时如果父类没有无参构造，则会产生编译错误</li></ul></li><li><p><strong>不能在静态方法中使用</strong></p></li><li><p>不能与 <code>this()</code> 共存</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 调用父类属性</span>
<span class="token keyword">super</span><span class="token punctuation">.</span>month<span class="token punctuation">;</span>

<span class="token comment">// 调用父类方法</span>
<span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 调用父类构造方法</span>
<span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> month<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="final-关键字" tabindex="-1"><a class="header-anchor" href="#final-关键字" aria-hidden="true">#</a> final 关键字</h2><ul><li>修饰类：表示该类不允许被继承，<code>public</code> <code>final</code> 关键字顺序可颠倒 <ul><li><code>public final class Animal{}</code></li></ul></li><li>修饰类方法：表示该方法不允许被子类重写，<strong>不能用来修饰构造方法</strong><ul><li><code>public final void eat(){}</code></li></ul></li><li>修饰方法内局部变量：<strong>只要在具体使用之前进行赋值即可，一旦赋值不允许被修改</strong><ul><li><code>final int num; num = 10;</code></li></ul></li><li>修饰内部成员属性：<strong>若定义时未被初始化，则只能在构造函数或构造代码块中赋值</strong><ul><li><code>private final String name;</code></li></ul></li><li>修饰对象，对象的引用不可变，但对象的属性值可变</li><li>可配合 <code>static</code> 使用修饰方法和变量 <ul><li><code>public static final int num = 10;</code></li><li>只需要加载一次后续不需要修订的配置信息</li><li><code>final</code> 修饰的静态变量值必须在声明或静态初始化程序中赋值</li></ul></li><li>可提高性能，但会降低可扩展性</li></ul><h2 id="object-类" tabindex="-1"><a class="header-anchor" href="#object-类" aria-hidden="true">#</a> Object 类</h2><ul><li><p>是所有类的父类</p></li><li><p>一个类没有使用 extends 关键字明确标识继承关系，则默认继承 Object 类（包括数组）</p></li><li><p>每个类都可以使用 Object 类中定义的方法</p></li></ul><h2 id="方法重写" tabindex="-1"><a class="header-anchor" href="#方法重写" aria-hidden="true">#</a> 方法重写</h2><ul><li>在子类中定义，重写父类中的方法</li><li>方法名和参数列表（类型、个数、顺序）与父类完全一致，与方法参数名无关</li><li>父类中的静态方法不能被子类重写</li><li>父类和子类具有相同名称的静态方法时，当子类对象向上转型后，只能调用到父类原有的静态方法</li><li>方法的返回值和访问修饰符是允许有变化的 <ul><li>如果父类方法的返回值是 <code>void</code> 或 基本数据类型，则要求子类方法重写时返回类型与父类完全一致</li><li>如果父类方法的返回值是引用类型，则要求子类方法重写时返回类型与父类一致或为父类类型的子类</li><li><strong>访问修饰符：子类重写方法的访问修饰符访问范围要大于等与父类的访问范围</strong></li></ul></li><li><code>final</code> 修饰的方法不允许被重写</li><li><code>static</code> 修饰的方法 <ul><li>加了 <code>@Override</code> 后不允许被重写，不加则被视为子类的静态方法</li></ul></li></ul>`,18);function t(o,d){return a(),l("div",null,[s(" more "),c])}const r=n(e,[["render",t],["__file","10.继承.html.vue"]]);export{r as default};
