import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as a,a as o,f as n}from"./app-DdwQwFQ1.js";const r={},l=n('<h2 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理"><span>内存管理</span></a></h2><h3 id="堆栈" tabindex="-1"><a class="header-anchor" href="#堆栈"><span>堆栈</span></a></h3><h4 id="栈" tabindex="-1"><a class="header-anchor" href="#栈"><span>栈</span></a></h4><blockquote><p>每个方法（Method）在执行时，都会创建一个栈帧，用于存储局部变量表、操作数、动态链接、方法出口信息等</p></blockquote><ul><li><p>栈中所存储，多用于保存局部信息的值，比如：方法中的基本数据类型定义的变量、对象的引用（也称为对象实例）等。当局部作用范围结束时，站内信息立即自动释放。</p></li><li><p>当存储内容是由基本数据类型（byte、short、long、double、char、boolean）声明的局部变量时，在栈中存储的是他们对应的具体数值。</p></li><li><p>当存储的是局部的对象的引用（定义在方法中的引用类型的变量）存储的是具体对象在堆中的地址。当然，如果对象的引用没有指向具体的空间，则是 <code>null</code></p></li></ul><h4 id="堆" tabindex="-1"><a class="header-anchor" href="#堆"><span>堆</span></a></h4><blockquote><p>用来存放动态产生的数据，比如 <code>new</code> 出来的对象。当对象使用结束，并确定已无实例指向堆空间时，JVM 才会依据相关垃圾回收机制进行资源回收，完成堆内资源释放，也就是说，并不是方法结束，方法内涉及到的堆空间就会立即释放，这也是与栈管理不同的地方。</p></blockquote><ul><li>创建出来的对象只包含属于各自的成员变量，并不包括成员方法。因为同一个类拥有各自的成员变量，存储在堆中的不同位置，但是同一个类的不同实例之间共享该类的方法，并不是每创建一个对象就把成员方法复制一次</li></ul>',8);function c(i,p){return t(),a("div",null,[o(" more "),l])}const m=e(r,[["render",c],["__file","内存管理.html.vue"]]),h=JSON.parse(`{"path":"/notes/java/Java%E8%BF%9B%E9%98%B6/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html","title":"Java","lang":"zh-CN","frontmatter":{"title":"Java","icon":"java","article":true,"breadcrumb":false,"date":"2023-02-22T00:00:00.000Z","category":["Java"],"tag":["Java基础"],"head":[["meta",{"property":"og:url","content":"https://codemake.fun/notes/java/Java%E8%BF%9B%E9%98%B6/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Yang's Blog"}],["meta",{"property":"og:title","content":"Java"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-01T04:40:50.000Z"}],["meta",{"property":"article:author","content":"Yang"}],["meta",{"property":"article:tag","content":"Java基础"}],["meta",{"property":"article:published_time","content":"2023-02-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-04-01T04:40:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-02-22T00:00:00.000Z\\",\\"dateModified\\":\\"2023-04-01T04:40:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yang\\",\\"url\\":\\"https://codemake.fun/\\",\\"email\\":\\"874530670@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"内存管理","slug":"内存管理","link":"#内存管理","children":[{"level":3,"title":"堆栈","slug":"堆栈","link":"#堆栈","children":[]}]}],"git":{"createdTime":1680324050000,"updatedTime":1680324050000,"contributors":[{"name":"sunzhenyang","email":"874530670@qq.com","commits":1}]},"readingTime":{"minutes":1.45,"words":435},"filePathRelative":"notes/java/Java进阶/内存管理.md","localizedDate":"2023年2月22日","excerpt":""}`);export{m as comp,h as data};
