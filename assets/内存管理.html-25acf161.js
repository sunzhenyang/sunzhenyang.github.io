import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as o,a as r,f as t}from"./app-a7325d6d.js";const c={},l=t('<h2 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理" aria-hidden="true">#</a> 内存管理</h2><h3 id="堆栈" tabindex="-1"><a class="header-anchor" href="#堆栈" aria-hidden="true">#</a> 堆栈</h3><h4 id="栈" tabindex="-1"><a class="header-anchor" href="#栈" aria-hidden="true">#</a> 栈</h4><blockquote><p>每个方法（Method）在执行时，都会创建一个栈帧，用于存储局部变量表、操作数、动态链接、方法出口信息等</p></blockquote><ul><li><p>栈中所存储，多用于保存局部信息的值，比如：方法中的基本数据类型定义的变量、对象的引用（也称为对象实例）等。当局部作用范围结束时，站内信息立即自动释放。</p></li><li><p>当存储内容是由基本数据类型（byte、short、long、double、char、boolean）声明的局部变量时，在栈中存储的是他们对应的具体数值。</p></li><li><p>当存储的是局部的对象的引用（定义在方法中的引用类型的变量）存储的是具体对象在堆中的地址。当然，如果对象的引用没有指向具体的空间，则是 <code>null</code></p></li></ul><h4 id="堆" tabindex="-1"><a class="header-anchor" href="#堆" aria-hidden="true">#</a> 堆</h4><blockquote><p>用来存放动态产生的数据，比如 <code>new</code> 出来的对象。当对象使用结束，并确定已无实例指向堆空间时，JVM 才会依据相关垃圾回收机制进行资源回收，完成堆内资源释放，也就是说，并不是方法结束，方法内涉及到的堆空间就会立即释放，这也是与栈管理不同的地方。</p></blockquote><ul><li>创建出来的对象只包含属于各自的成员变量，并不包括成员方法。因为同一个类拥有各自的成员变量，存储在堆中的不同位置，但是同一个类的不同实例之间共享该类的方法，并不是每创建一个对象就把成员方法复制一次</li></ul>',8);function d(i,h){return a(),o("div",null,[r(" more "),l])}const u=e(c,[["render",d],["__file","内存管理.html.vue"]]);export{u as default};
