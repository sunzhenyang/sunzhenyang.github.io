const e=JSON.parse(`{"key":"v-5c3fe13b","path":"/technology/webapi/intersectionObserver.html","title":"IntersectionObserver","lang":"zh-CN","frontmatter":{"title":"IntersectionObserver","icon":"article","category":"Web API","article":false,"tag":["Web API"],"copyright":"Copyright by 阮一峰","description":"网页开发时，常常需要了解某个元素是否进入了“视口”（viewport），即用户能不能看到它。 上图的绿色方块不断滚动，顶部会提示它的可见性。 传统的实现方法是，监听到scroll事件后，调用目标元素（绿色方块）的getBoundingClientRect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于scroll事件密集发生，计算量很大，容易造成性能问题。","head":[["meta",{"property":"og:url","content":"https://codemake.fun/technology/webapi/intersectionObserver.html"}],["meta",{"property":"og:site_name","content":"Yang's Blog"}],["meta",{"property":"og:title","content":"IntersectionObserver"}],["meta",{"property":"og:description","content":"网页开发时，常常需要了解某个元素是否进入了“视口”（viewport），即用户能不能看到它。 上图的绿色方块不断滚动，顶部会提示它的可见性。 传统的实现方法是，监听到scroll事件后，调用目标元素（绿色方块）的getBoundingClientRect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于scroll事件密集发生，计算量很大，容易造成性能问题。"}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-01-11T09:12:15.000Z"}],["meta",{"property":"article:tag","content":"Web API"}],["meta",{"property":"article:modified_time","content":"2023-01-11T09:12:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"IntersectionObserver\\",\\"description\\":\\"网页开发时，常常需要了解某个元素是否进入了“视口”（viewport），即用户能不能看到它。 上图的绿色方块不断滚动，顶部会提示它的可见性。 传统的实现方法是，监听到scroll事件后，调用目标元素（绿色方块）的getBoundingClientRect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于scroll事件密集发生，计算量很大，容易造成性能问题。\\"}"]]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"IntersectionObserver.observe()","slug":"intersectionobserver-observe","link":"#intersectionobserver-observe","children":[{"level":3,"title":"callback 参数","slug":"callback-参数","link":"#callback-参数","children":[]},{"level":3,"title":"IntersectionObserverEntry 对象","slug":"intersectionobserverentry-对象","link":"#intersectionobserverentry-对象","children":[]},{"level":3,"title":"Option 对象","slug":"option-对象","link":"#option-对象","children":[]}]},{"level":2,"title":"实例","slug":"实例","link":"#实例","children":[{"level":3,"title":"惰性加载（lazy load）","slug":"惰性加载-lazy-load","link":"#惰性加载-lazy-load","children":[]},{"level":3,"title":"无限滚动","slug":"无限滚动","link":"#无限滚动","children":[]},{"level":3,"title":"视频自动播放","slug":"视频自动播放","link":"#视频自动播放","children":[]}]},{"level":2,"title":"参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"git":{"createdTime":1673428335000,"updatedTime":1673428335000,"contributors":[{"name":"sunzhenyang","email":"874530670@qq.com","commits":1}]},"readingTime":{"minutes":6.95,"words":2086},"filePathRelative":"technology/webapi/intersectionObserver.md","localizedDate":"2023年1月11日","excerpt":"<p>网页开发时，常常需要了解某个元素是否进入了“视口”（viewport），即用户能不能看到它。</p>\\n<figure><img src=\\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016110201.gif\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>\\n<p>上图的绿色方块不断滚动，顶部会提示它的可见性。</p>\\n<p>传统的实现方法是，监听到<code>scroll</code>事件后，调用目标元素（绿色方块）的<a href=\\"https://developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>getBoundingClientRect()</code></a>方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于<code>scroll</code>事件密集发生，计算量很大，容易造成<a href=\\"http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">性能问题</a>。</p>","autoDesc":true}`);export{e as data};
