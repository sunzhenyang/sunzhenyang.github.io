import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as l,a as i,f as o}from"./app-BybQgHW9.js";const a={},c=o('<blockquote><p>解决多重继承问题，但又不会产生致命方块的问题</p></blockquote><h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h2><ul><li><p>接口定义了某一批类所需要遵守的规范</p><ul><li>定义：<code>public interface test(){}</code></li></ul></li><li><p>接口不关心这些类的内部数据，也不关心这些类里的方法的实现细节，它之规定这些类里必须提供某些方法</p></li><li><p>实现类必须实现接口中所有方法，未全部实现则需将类变为抽象类</p></li><li><p>调用：<code>import 包名.*</code> 或 <code>import 包名.接口名</code></p></li><li><p>接口不能实例化，只能通过引用指向类实例</p></li><li><p>接口的灵活性就在于“规定一个类必须做什么，而不管你如何做”。可以<strong>定义一个接口类型的引用来指向实现接口的类的实例，当这个引用调用方法时，会根据实际引用类的实例来判断具体调用哪个方法，这是一种典型的多态的表现</strong></p></li><li><p><strong>当接口引用指向实现类时，不能直接调用实现类独有的方法，需要进行强制类型转换才可以调用</strong></p></li><li><p>默认方法和静态方法自 JDK1.8 后可以在接口中应用，默认方法可以在实现类中应用，静态方法只属于接口</p></li><li><p>在一个Java文件中可以存在多个类，多个接口。但是 <strong>只能存在一个public修饰的类或接口</strong>，且此时<strong>文件名需要与public修饰的类或者接口同名</strong></p></li><li><p>接口只能使用两种访问修饰符</p><ul><li><strong>默认访问权限（包内可见）</strong></li><li><code>public</code></li></ul></li><li><p>常量</p><ul><li>默认访问修饰符： <code>public static final</code> ，三个任意一个缺省不影响使用</li><li>接口中定义的常量在定义时必须初始化</li><li>可通过 <code>接口名.常量名</code> 访问</li></ul></li><li><p>抽象方法（成员方法）</p><ul><li>默认访问修饰符：<code>public abstract</code> ，两个任意一个缺省不影响使用</li><li>实现类中实现抽象方法后，可通过 <strong>接口引用</strong> 或者 <strong>实现类引用</strong> 访问相关方法</li></ul></li><li><p>默认方法</p><ul><li>接口中可以使用 <code>default</code> 关键字定义默认方法，子类中不需要实现，可以带方法体</li><li>定义：<strong><code>public default 返回值类型 方法名(参数列表){方法体}</code></strong> （<code>public</code> 为默认访问修饰符，可省略）</li><li>可以在实现类中重写与重载，重写时去掉 <code>default</code> 关键字，重载的方法无法通过接口引用访问 <ul><li>重写方法后，可以通过 <strong><code>接口名.super.默认方法名()</code></strong> 调用接口中原有的默认方法，不加 <code>super</code> 只能调用接口的静态成员</li></ul></li><li>使用场景：使用接口中的某些方法，而其他一些方法重新实现没有意义</li></ul></li><li><p>静态方法</p><ul><li>接口中可以使用 <code>static</code> 关键字定义静态方法，可以带方法体</li><li>实现类中无法继承接口中的静态方法</li><li>不可以在实现类中重写，可以存在相同静态格式，但相互独立</li><li>定义：<strong><code>public static 返回值类型 方法名(参数列表){方法体}</code></strong> （<code>public</code> 为默认访问修饰符，可省略）</li><li>在实现类中需要通过接口名进行访问</li><li>使用场景：希望更多的接口拓展方法支持在无实例对象产生的情况下调用</li></ul></li></ul><h2 id="多接口" tabindex="-1"><a class="header-anchor" href="#多接口"><span>多接口</span></a></h2><ul><li><p>实现类可以通过 <code>implements</code> 实现多个接口，通过 <strong>逗号分隔</strong>，当实现类同时继承父类并实现接口时，需要先继承后实现</p></li><li><p>多个接口中存在相同成员，类同时实现多个接口，子类无法分辨，需要在子类中重新定义</p></li><li><p>继承的父类和实现的接口中存在相同定义的成员，类中无实现时，会优先继承父类的成员及静态方法</p></li></ul><h2 id="接口继承" tabindex="-1"><a class="header-anchor" href="#接口继承"><span>接口继承</span></a></h2><ul><li>子接口可以通过 <code>extends</code> 继承多个接口，接口之间通过逗号分隔</li><li>多个接口中有重名方法，子接口继承时应重写父接口中的重名方法</li><li>单继承中：子接口可继承父接口中定义的常量、抽象方法、默认方法，无法继承静态方法</li><li>多继承中：只可继承父接口中定义的抽象方法，常量和默认方法无法分辨</li></ul><h2 id="接口与抽象类" tabindex="-1"><a class="header-anchor" href="#接口与抽象类"><span>接口与抽象类</span></a></h2><ul><li>抽象类通常用来捕捉子类的通用特性，即更加侧重重用</li><li>接口多是为了把程序模块进行固化的契约，即侧重降低耦合，可以理解为 <strong>更加抽象的抽象类</strong></li><li>当希望描述多种毫无关系的类型之间的共同行为能力，更推荐用接口</li><li>当多类间可以形成可追溯的产生轨迹，则更推荐抽象类继承</li></ul>',9);function r(n,p){return t(),l("div",null,[i(" more "),c])}const u=e(a,[["render",r],["__file","12.接口.html.vue"]]),m=JSON.parse(`{"path":"/notes/java/Java%E5%9F%BA%E7%A1%80/12.%E6%8E%A5%E5%8F%A3.html","title":"接口","lang":"zh-CN","frontmatter":{"title":"接口","icon":"java","article":true,"breadcrumb":false,"date":"2023-03-05T00:00:00.000Z","order":12,"category":["Java"],"tag":["Java基础"],"description":"解决多重继承问题，但又不会产生致命方块的问题 基本概念 接口定义了某一批类所需要遵守的规范 定义：public interface test(){} 接口不关心这些类的内部数据，也不关心这些类里的方法的实现细节，它之规定这些类里必须提供某些方法 实现类必须实现接口中所有方法，未全部实现则需将类变为抽象类 调用：import 包名.* 或 import ...","head":[["meta",{"property":"og:url","content":"https://codemake.fun/notes/java/Java%E5%9F%BA%E7%A1%80/12.%E6%8E%A5%E5%8F%A3.html"}],["meta",{"property":"og:site_name","content":"Yang's Blog"}],["meta",{"property":"og:title","content":"接口"}],["meta",{"property":"og:description","content":"解决多重继承问题，但又不会产生致命方块的问题 基本概念 接口定义了某一批类所需要遵守的规范 定义：public interface test(){} 接口不关心这些类的内部数据，也不关心这些类里的方法的实现细节，它之规定这些类里必须提供某些方法 实现类必须实现接口中所有方法，未全部实现则需将类变为抽象类 调用：import 包名.* 或 import ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-01T04:40:50.000Z"}],["meta",{"property":"article:author","content":"Yang"}],["meta",{"property":"article:tag","content":"Java基础"}],["meta",{"property":"article:published_time","content":"2023-03-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-04-01T04:40:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"接口\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-05T00:00:00.000Z\\",\\"dateModified\\":\\"2023-04-01T04:40:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yang\\",\\"url\\":\\"https://codemake.fun/\\",\\"email\\":\\"874530670@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]},{"level":2,"title":"多接口","slug":"多接口","link":"#多接口","children":[]},{"level":2,"title":"接口继承","slug":"接口继承","link":"#接口继承","children":[]},{"level":2,"title":"接口与抽象类","slug":"接口与抽象类","link":"#接口与抽象类","children":[]}],"git":{"createdTime":1680324050000,"updatedTime":1680324050000,"contributors":[{"name":"sunzhenyang","email":"874530670@qq.com","commits":1}]},"readingTime":{"minutes":4.11,"words":1232},"filePathRelative":"notes/java/Java基础/12.接口.md","localizedDate":"2023年3月5日","excerpt":"","autoDesc":true}`);export{u as comp,m as data};
