import{_ as l,Q as i,S as e,$ as c,a3 as o}from"./framework-2ed98ecf.js";const d={},a=o('<blockquote><p>解决多重继承问题，但又不会产生致命方块的问题</p></blockquote><h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h2><ul><li><p>接口定义了某一批类所需要遵守的规范</p></li><li><p>接口不能实例化，只能通过引用指向类实例</p></li><li><p>接口不关心这些类的内部数据，也不关心这些类里的方法的实现细节，它之规定这些类里必须提供某些方法</p></li><li><p>实现类必须实现接口中所有方法，未全部实现则需将类变为抽象类</p></li><li><p>可以根据业务需要创建接口包，需设置接口为 <code>public</code> 访问权限</p><ul><li>调用：<code>import 包名.*</code> 或 <code>import 包名.接口名</code></li></ul></li><li><p>接口不能直接实例化对象，只能设置接口的引用指向具体的接口实现类。接口的灵活性就在于“规定一个类必须做什么，而不管你如何做”。可以<strong>定义一个接口类型的引用来指向实现接口的类的实例，当这个引用调用方法时，会根据实际引用类的实例来判断具体调用哪个方法，这是一种典型的多态的表现</strong></p></li><li><p>当<strong>接口引用指向实现类时，不能直接调用实现类独有的方法，需要进行强制类型转换才可以调用</strong></p></li><li><p>默认方法和静态方法自 JDK1.8 后可以在接口中应用，默认方法可以在实现类中应用，静态方法只属于接口</p></li><li><p>接口访问修饰符</p><ul><li><strong>默认访问权限（包内可见）</strong></li><li><code>public</code></li></ul></li><li><p>常量</p><ul><li>默认访问修饰符： <code>public static final</code> ，缺省不影响使用</li><li>接口中定义的常量在定义时必须初始化</li><li>可通过 <code>接口名.常量</code> 访问</li></ul></li><li><p>抽象方法（成员方法）</p><ul><li>默认访问修饰符：<code>public abstract</code> ，缺省不影响使用</li><li>实现类中实现抽象方法后，可通过接口引用或者实现类引用访问相关方法</li></ul></li><li><p>默认方法</p><ul><li>接口中可以使用 <code>default</code> 关键字定义默认方法，子类中不需要实现，可以带方法体</li><li>使用场景：使用接口中的某些方法，而其他一些方法重新实现没有意义</li><li><code>public default 返回值类型 方法名(参数列表){方法体}</code> （<code>public</code> 为默认访问修饰符，可省略）</li><li>使用场景：希望实现类能更多地应用接口中的方法</li></ul></li><li><p>静态方法</p><ul><li>接口中可以使用 <code>static</code> 关键字定义静态方法，可以带方法体</li><li>实现类无法重写静态方法，可以存在相同静态格式，但相互独立</li><li><code>public static 返回值类型 方法名(参数列表){方法体}</code> （<code>public</code> 为默认访问修饰符，可省略）</li><li>在实现类中需要通过接口名进行访问</li><li>使用场景：希望更多的接口拓展方法支持在无实例对象产生的情况下调用</li></ul></li></ul><h2 id="多接口" tabindex="-1"><a class="header-anchor" href="#多接口" aria-hidden="true">#</a> 多接口</h2><ul><li><p>实现类可以通过 <code>implements</code> 实现多个接口，通过逗号分隔，当实现类同事继承父类并实现接口时，需要先继承后实现</p></li><li><p>多个接口中存在相同成员，类同时实现多个接口，子类无法分辨，需要在子类中重新定义</p></li><li><p>继承的父类和实现的接口中存在相同定义的成员，类中无实现时，会优先继承父类的成员及静态方法</p></li></ul><h2 id="接口继承" tabindex="-1"><a class="header-anchor" href="#接口继承" aria-hidden="true">#</a> 接口继承</h2><ul><li>子接口可以通过 <code>extends</code> 继承多个接口，接口之间通过逗号分隔</li><li>多个接口中有重名方法，子接口继承时应重写父接口中的重名方法</li><li>单继承：子接口可继承父接口中定义的常量、抽象方法、默认方法，无法继承静态方法</li><li>多继承：只可继承父接口中定义的抽象方法，常量和默认方法无法分辨</li></ul><h2 id="接口与抽象类" tabindex="-1"><a class="header-anchor" href="#接口与抽象类" aria-hidden="true">#</a> 接口与抽象类</h2><ul><li>抽象类通常用来捕捉子类的通用特性，即更加侧重重用</li><li>接口多是为了把程序模块进行固化的契约，即侧重降低耦合，可以理解为 <strong>&quot;更加抽象的抽象类&quot;</strong>，</li><li>当希望描述多种毫无关系的类型之间的共同行为能力，更推荐用接口</li><li>当多类间可以形成可追溯侧产生轨迹，则更对剑抽象类继承</li></ul>',9);function t(p,r){return i(),e("div",null,[c(" more "),a])}const n=l(d,[["render",t],["__file","12.接口.html.vue"]]);export{n as default};
